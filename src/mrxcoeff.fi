!------------------------------------------------------------------------------!
! thermal diffusion
! alpha prescription
! no thermal conduction
pure subroutine mrx_coeff1_ad (z,Y,D,F,A,MY,MD)
use iso_fortran_env, only: dp => real64
implicit none
real(dp), intent(in) :: z
! first column: values, second column: 1ord derivatives
real(dp), dimension(:), intent(in) :: Y,D
! each row is one Function: its value and derivatives to rho and T
real(dp), dimension(:,:), intent(in) :: F
! right-hand-side of the equation
real(dp), dimension(:), intent(out) :: A
! jacobians with respect to Y and dY/dz
real(dp), dimension(:,:), intent(out) :: MY, MD
A(1) = (-cgs_boltz*cgs_c*(D(1)*Y(2) + D(2)*Y(1)) - cgs_c*cgs_mhydr*miu* &
      omega**2*z*Y(1) + cgs_mhydr*miu*(F(1,1) + F(1,2))*Y(1)*Y(3))/( &
      cgs_c*cgs_mhydr*miu)
A(2) = -16*cgs_stef*D(2)*Y(2)**3 - 3*(F(1,1) + F(1,2))*Y(1)*Y(3)
A(3) = alpha*cgs_boltz*omega*Y(1)*Y(2)/(cgs_mhydr*miu) + (4.0d0/3.0d0)* &
      alpha*cgs_stef*omega*Y(2)**4/cgs_c - D(3)
MY(1,1) = (cgs_boltz*cgs_c*D(2) + cgs_c*cgs_mhydr*miu*omega**2*z - &
      cgs_mhydr*miu*((F(2,1) + F(2,2))*Y(1) + F(1,1) + F(1,2))*Y(3))/( &
      cgs_c*cgs_mhydr*miu)
MY(2,1) = 3*((F(2,1) + F(2,2))*Y(1) + F(1,1) + F(1,2))*Y(3)
MY(3,1) = -alpha*cgs_boltz*omega*Y(2)/(cgs_mhydr*miu)
MY(1,2) = (cgs_boltz*cgs_c*D(1) - cgs_mhydr*miu*(F(3,1) + F(3,2))*Y(1)*Y &
      (3))/(cgs_c*cgs_mhydr*miu)
MY(2,2) = 48*cgs_stef*D(2)*Y(2)**2 + 3*(F(3,1) + F(3,2))*Y(1)*Y(3)
MY(3,2) = -alpha*cgs_boltz*omega*Y(1)/(cgs_mhydr*miu) - 16.0d0/3.0d0* &
      alpha*cgs_stef*omega*Y(2)**3/cgs_c
MY(1,3) = -(F(1,1) + F(1,2))*Y(1)/cgs_c
MY(2,3) = 3*(F(1,1) + F(1,2))*Y(1)
MY(3,3) = 0
MD(1,1) = cgs_boltz*Y(2)/(cgs_mhydr*miu)
MD(2,1) = 0
MD(3,1) = 0
MD(1,2) = cgs_boltz*Y(1)/(cgs_mhydr*miu)
MD(2,2) = 16*cgs_stef*Y(2)**3
MD(3,2) = 0
MD(1,3) = 0
MD(2,3) = 0
MD(3,3) = 1
end subroutine

pure subroutine mrx_coeffbl_ad (z,Y,F,B,MB)
use iso_fortran_env, only: dp => real64
implicit none
real(dp), intent(in) :: z
real(dp), dimension(:), intent(in) :: Y
real(dp), dimension(:,:), intent(in) :: F
real(dp), dimension(:), intent(out) :: B
real(dp), dimension(:,:), intent(out) :: MB
B(1) = -Y(3)
MB(1,1) = 0
MB(1,2) = 0
MB(1,3) = 1
end subroutine

pure subroutine mrx_coeffbr_ad (z,Y,F,B,MB)
use iso_fortran_env, only: dp => real64
implicit none
real(dp), intent(in) :: z
real(dp), dimension(:), intent(in) :: Y
real(dp), dimension(:,:), intent(in) :: F
real(dp), dimension(:), intent(out) :: B
real(dp), dimension(:,:), intent(out) :: MB
B(1) = facc - Y(3)
B(2) = 2*cgs_stef*Y(2)**4 - Y(3)
MB(1,1) = 0
MB(2,1) = 0
MB(1,2) = 0
MB(2,2) = -8*cgs_stef*Y(2)**3
MB(1,3) = 1
MB(2,3) = 1
end subroutine

pure subroutine mrx_output_ad (z,Y,YY)
use iso_fortran_env, only: dp => real64
implicit none
real(dp), intent(in) :: z
real(dp), dimension(:), intent(in) :: Y
real(dp), dimension(:), intent(out) :: YY
YY(1) = Y(1)
YY(2) = Y(2)
YY(3) = Y(2)
YY(4) = cgs_boltz*Y(1)*Y(2)/(cgs_mhydr*miu)
YY(5) = (4.0d0/3.0d0)*cgs_stef*Y(2)**4/cgs_c
YY(6) = 0
YY(7) = Y(3)
YY(8) = 0
YY(9) = 0
YY(10) = alpha*cgs_boltz*omega*Y(1)*Y(2)/(cgs_mhydr*miu) + (4.0d0/3.0d0) &
      *alpha*cgs_stef*omega*Y(2)**4/cgs_c
YY(11) = omega*z*zeta
end subroutine

!------------------------------------------------------------------------------!
! thermal diffusion
! alpha prescription
! radiation + thermal conduction
pure subroutine mrx_coeff1_adt (z,Y,D,F,A,MY,MD)
use iso_fortran_env, only: dp => real64
implicit none
real(dp), intent(in) :: z
! first column: values, second column: 1ord derivatives
real(dp), dimension(:), intent(in) :: Y,D
! each row is one Function: its value and derivatives to rho and T
real(dp), dimension(:,:), intent(in) :: F
! right-hand-side of the equation
real(dp), dimension(:), intent(out) :: A
! jacobians with respect to Y and dY/dz
real(dp), dimension(:,:), intent(out) :: MY, MD
A(1) = (-cgs_boltz*cgs_c*(D(1)*Y(2) + D(2)*Y(1)) - cgs_c*cgs_mhydr*miu* &
      omega**2*z*Y(1) + cgs_mhydr*miu*(F(1,1) + F(1,2))*Y(1)*Y(3))/( &
      cgs_c*cgs_mhydr*miu)
A(2) = -16*cgs_stef*D(2)*Y(2)**3 - 3*(F(1,1) + F(1,2))*Y(1)*Y(3)
A(3) = alpha*cgs_boltz*omega*Y(1)*Y(2)/(cgs_mhydr*miu) + (4.0d0/3.0d0)* &
      alpha*cgs_stef*omega*Y(2)**4/cgs_c - D(3) - D(4)
A(4) = -D(2)*F(1,3) - Y(4)
MY(1,1) = (cgs_boltz*cgs_c*D(2) + cgs_c*cgs_mhydr*miu*omega**2*z - &
      cgs_mhydr*miu*((F(2,1) + F(2,2))*Y(1) + F(1,1) + F(1,2))*Y(3))/( &
      cgs_c*cgs_mhydr*miu)
MY(2,1) = 3*((F(2,1) + F(2,2))*Y(1) + F(1,1) + F(1,2))*Y(3)
MY(3,1) = -alpha*cgs_boltz*omega*Y(2)/(cgs_mhydr*miu)
MY(4,1) = D(2)*F(2,3)
MY(1,2) = (cgs_boltz*cgs_c*D(1) - cgs_mhydr*miu*(F(3,1) + F(3,2))*Y(1)*Y &
      (3))/(cgs_c*cgs_mhydr*miu)
MY(2,2) = 48*cgs_stef*D(2)*Y(2)**2 + 3*(F(3,1) + F(3,2))*Y(1)*Y(3)
MY(3,2) = -alpha*cgs_boltz*omega*Y(1)/(cgs_mhydr*miu) - 16.0d0/3.0d0* &
      alpha*cgs_stef*omega*Y(2)**3/cgs_c
MY(4,2) = D(2)*F(3,3)
MY(1,3) = -(F(1,1) + F(1,2))*Y(1)/cgs_c
MY(2,3) = 3*(F(1,1) + F(1,2))*Y(1)
MY(3,3) = 0
MY(4,3) = 0
MY(1,4) = 0
MY(2,4) = 0
MY(3,4) = 0
MY(4,4) = 1
MD(1,1) = cgs_boltz*Y(2)/(cgs_mhydr*miu)
MD(2,1) = 0
MD(3,1) = 0
MD(4,1) = 0
MD(1,2) = cgs_boltz*Y(1)/(cgs_mhydr*miu)
MD(2,2) = 16*cgs_stef*Y(2)**3
MD(3,2) = 0
MD(4,2) = F(1,3)
MD(1,3) = 0
MD(2,3) = 0
MD(3,3) = 1
MD(4,3) = 0
MD(1,4) = 0
MD(2,4) = 0
MD(3,4) = 1
MD(4,4) = 0
end subroutine

pure subroutine mrx_coeffbl_adt (z,Y,F,B,MB)
use iso_fortran_env, only: dp => real64
implicit none
real(dp), intent(in) :: z
real(dp), dimension(:), intent(in) :: Y
real(dp), dimension(:,:), intent(in) :: F
real(dp), dimension(:), intent(out) :: B
real(dp), dimension(:,:), intent(out) :: MB
B(1) = -Y(3)
B(2) = -Y(4)
MB(1,1) = 0
MB(2,1) = 0
MB(1,2) = 0
MB(2,2) = 0
MB(1,3) = 1
MB(2,3) = 0
MB(1,4) = 0
MB(2,4) = 1
end subroutine

pure subroutine mrx_coeffbr_adt (z,Y,F,B,MB)
use iso_fortran_env, only: dp => real64
implicit none
real(dp), intent(in) :: z
real(dp), dimension(:), intent(in) :: Y
real(dp), dimension(:,:), intent(in) :: F
real(dp), dimension(:), intent(out) :: B
real(dp), dimension(:,:), intent(out) :: MB
B(1) = facc - Y(3) - Y(4)
B(2) = 2*cgs_stef*Y(2)**4 - Y(3)
MB(1,1) = 0
MB(2,1) = 0
MB(1,2) = 0
MB(2,2) = -8*cgs_stef*Y(2)**3
MB(1,3) = 1
MB(2,3) = 1
MB(1,4) = 1
MB(2,4) = 0
end subroutine

pure subroutine mrx_output_adt (z,Y,YY)
use iso_fortran_env, only: dp => real64
implicit none
real(dp), intent(in) :: z
real(dp), dimension(:), intent(in) :: Y
real(dp), dimension(:), intent(out) :: YY
YY(1) = Y(1)
YY(2) = Y(2)
YY(3) = Y(2)
YY(4) = cgs_boltz*Y(1)*Y(2)/(cgs_mhydr*miu)
YY(5) = (4.0d0/3.0d0)*cgs_stef*Y(2)**4/cgs_c
YY(6) = 0
YY(7) = Y(3)
YY(8) = 0
YY(9) = Y(4)
YY(10) = alpha*cgs_boltz*omega*Y(1)*Y(2)/(cgs_mhydr*miu) + (4.0d0/3.0d0) &
      *alpha*cgs_stef*omega*Y(2)**4/cgs_c
YY(11) = omega*z*zeta
end subroutine

!------------------------------------------------------------------------------!
! thermal diffusion
! magnetic heating
! no thermal conduction
pure subroutine mrx_coeff1_md (z,Y,D,F,A,MY,MD)
use iso_fortran_env, only: dp => real64
implicit none
real(dp), intent(in) :: z
! first column: values, second column: 1ord derivatives
real(dp), dimension(:), intent(in) :: Y,D
! each row is one Function: its value and derivatives to rho and T
real(dp), dimension(:,:), intent(in) :: F
! right-hand-side of the equation
real(dp), dimension(:), intent(out) :: A
! jacobians with respect to Y and dY/dz
real(dp), dimension(:,:), intent(out) :: MY, MD
A(1) = (-cgs_boltz*cgs_c*(D(1)*Y(2) + D(2)*Y(1)) - cgs_c*cgs_mhydr*miu*( &
      omega**2*z*Y(1) + D(4)) + cgs_mhydr*miu*(F(1,1) + F(1,2))*Y(1)*Y( &
      3))/(cgs_c*cgs_mhydr*miu)
A(2) = -16*cgs_stef*D(2)*Y(2)**3 - 3*(F(1,1) + F(1,2))*Y(1)*Y(3)
A(3) = -alpha*cgs_boltz*omega*Y(1)*Y(2)/(cgs_mhydr*miu) + 2*alpha*nu* &
      omega*Y(4) - alpha*omega*Y(4) - 4.0d0/3.0d0*alpha*cgs_stef*omega* &
      Y(2)**4/cgs_c + 2*omega*zeta*Y(4) - D(3)
A(4) = alpha*cgs_boltz*omega*Y(1)*Y(2)/(cgs_mhydr*miu) - alpha*nu*omega* &
      Y(4) + alpha*omega*Y(4) + (4.0d0/3.0d0)*alpha*cgs_stef*omega*Y(2) &
      **4/cgs_c - omega*z*zeta*D(4) - 2*omega*zeta*Y(4)
MY(1,1) = (cgs_boltz*cgs_c*D(2) + cgs_c*cgs_mhydr*miu*omega**2*z - &
      cgs_mhydr*miu*((F(2,1) + F(2,2))*Y(1) + F(1,1) + F(1,2))*Y(3))/( &
      cgs_c*cgs_mhydr*miu)
MY(2,1) = 3*((F(2,1) + F(2,2))*Y(1) + F(1,1) + F(1,2))*Y(3)
MY(3,1) = alpha*cgs_boltz*omega*Y(2)/(cgs_mhydr*miu)
MY(4,1) = -alpha*cgs_boltz*omega*Y(2)/(cgs_mhydr*miu)
MY(1,2) = (cgs_boltz*cgs_c*D(1) - cgs_mhydr*miu*(F(3,1) + F(3,2))*Y(1)*Y &
      (3))/(cgs_c*cgs_mhydr*miu)
MY(2,2) = 48*cgs_stef*D(2)*Y(2)**2 + 3*(F(3,1) + F(3,2))*Y(1)*Y(3)
MY(3,2) = alpha*cgs_boltz*omega*Y(1)/(cgs_mhydr*miu) + (16.0d0/3.0d0)* &
      alpha*cgs_stef*omega*Y(2)**3/cgs_c
MY(4,2) = -alpha*cgs_boltz*omega*Y(1)/(cgs_mhydr*miu) - 16.0d0/3.0d0* &
      alpha*cgs_stef*omega*Y(2)**3/cgs_c
MY(1,3) = -(F(1,1) + F(1,2))*Y(1)/cgs_c
MY(2,3) = 3*(F(1,1) + F(1,2))*Y(1)
MY(3,3) = 0
MY(4,3) = 0
MY(1,4) = 0
MY(2,4) = 0
MY(3,4) = omega*(-2*alpha*nu + alpha - 2*zeta)
MY(4,4) = omega*(alpha*(nu - 1) + 2*zeta)
MD(1,1) = cgs_boltz*Y(2)/(cgs_mhydr*miu)
MD(2,1) = 0
MD(3,1) = 0
MD(4,1) = 0
MD(1,2) = cgs_boltz*Y(1)/(cgs_mhydr*miu)
MD(2,2) = 16*cgs_stef*Y(2)**3
MD(3,2) = 0
MD(4,2) = 0
MD(1,3) = 0
MD(2,3) = 0
MD(3,3) = 1
MD(4,3) = 0
MD(1,4) = 1
MD(2,4) = 0
MD(3,4) = 0
MD(4,4) = omega*z*zeta
end subroutine

pure subroutine mrx_coeffbl_md (z,Y,F,B,MB)
use iso_fortran_env, only: dp => real64
implicit none
real(dp), intent(in) :: z
real(dp), dimension(:), intent(in) :: Y
real(dp), dimension(:,:), intent(in) :: F
real(dp), dimension(:), intent(out) :: B
real(dp), dimension(:,:), intent(out) :: MB
B(1) = -Y(3)
B(2) = alpha*cgs_boltz*omega*Y(1)*Y(2)/(cgs_mhydr*miu) - alpha*nu*omega* &
      Y(4) + alpha*omega*Y(4) + (4.0d0/3.0d0)*alpha*cgs_stef*omega*Y(2) &
      **4/cgs_c - 2*omega*zeta*Y(4)
MB(1,1) = 0
MB(2,1) = -alpha*cgs_boltz*omega*Y(2)/(cgs_mhydr*miu)
MB(1,2) = 0
MB(2,2) = -alpha*cgs_boltz*omega*Y(1)/(cgs_mhydr*miu) - 16.0d0/3.0d0* &
      alpha*cgs_stef*omega*Y(2)**3/cgs_c
MB(1,3) = 1
MB(2,3) = 0
MB(1,4) = 0
MB(2,4) = omega*(alpha*(nu - 1) + 2*zeta)
end subroutine

pure subroutine mrx_coeffbr_md (z,Y,F,B,MB)
use iso_fortran_env, only: dp => real64
implicit none
real(dp), intent(in) :: z
real(dp), dimension(:), intent(in) :: Y
real(dp), dimension(:,:), intent(in) :: F
real(dp), dimension(:), intent(out) :: B
real(dp), dimension(:,:), intent(out) :: MB
B(1) = facc - 2*omega*z*zeta*Y(4) - Y(3)
B(2) = 2*cgs_stef*Y(2)**4 - Y(3)
MB(1,1) = 0
MB(2,1) = 0
MB(1,2) = 0
MB(2,2) = -8*cgs_stef*Y(2)**3
MB(1,3) = 1
MB(2,3) = 1
MB(1,4) = 2*omega*z*zeta
MB(2,4) = 0
end subroutine

pure subroutine mrx_output_md (z,Y,YY)
use iso_fortran_env, only: dp => real64
implicit none
real(dp), intent(in) :: z
real(dp), dimension(:), intent(in) :: Y
real(dp), dimension(:), intent(out) :: YY
YY(1) = Y(1)
YY(2) = Y(2)
YY(3) = Y(2)
YY(4) = cgs_boltz*Y(1)*Y(2)/(cgs_mhydr*miu)
YY(5) = (4.0d0/3.0d0)*cgs_stef*Y(2)**4/cgs_c
YY(6) = Y(4)
YY(7) = Y(3)
YY(8) = 2*omega*z*zeta*Y(4)
YY(9) = 0
YY(10) = -alpha*cgs_boltz*omega*Y(1)*Y(2)/(cgs_mhydr*miu) + 2*alpha*nu* &
      omega*Y(4) - alpha*omega*Y(4) - 4.0d0/3.0d0*alpha*cgs_stef*omega* &
      Y(2)**4/cgs_c + 2*omega*zeta*Y(4)
YY(11) = omega*z*zeta
end subroutine

!------------------------------------------------------------------------------!
! heating-cooling balance (compton term only)
! magnetic heating
! no thermal conduction
pure subroutine mrx_coeff1_mw (z,Y,D,F,A,MY,MD)
use iso_fortran_env, only: dp => real64
implicit none
real(dp), intent(in) :: z
! first column: values, second column: 1ord derivatives
real(dp), dimension(:), intent(in) :: Y,D
! each row is one Function: its value and derivatives to rho and T
real(dp), dimension(:,:), intent(in) :: F
! right-hand-side of the equation
real(dp), dimension(:), intent(out) :: A
! jacobians with respect to Y and dY/dz
real(dp), dimension(:,:), intent(out) :: MY, MD
A(1) = (-cgs_boltz*cgs_c*(D(1)*Y(2) + D(2)*Y(1)) - cgs_c*cgs_mhydr*miu*( &
      omega**2*z*Y(1) + D(5)) + cgs_mhydr*miu*(F(1,1) + F(1,2))*Y(1)*Y( &
      4))/(cgs_c*cgs_mhydr*miu)
A(2) = -16*cgs_stef*D(3)*Y(3)**3 - 3*(F(1,1) + F(1,2))*Y(1)*Y(4)
A(3) = -alpha*cgs_boltz*omega*Y(1)*Y(2)/(cgs_mhydr*miu) + 2*alpha*nu* &
      omega*Y(5) - alpha*omega*Y(5) - 4.0d0/3.0d0*alpha*cgs_stef*omega* &
      Y(3)**4/cgs_c + 2*omega*zeta*Y(5) - D(4)
A(4) = alpha*cgs_boltz*omega*Y(1)*Y(2)/(cgs_mhydr*miu) - alpha*nu*omega* &
      Y(5) + alpha*omega*Y(5) + (4.0d0/3.0d0)*alpha*cgs_stef*omega*Y(3) &
      **4/cgs_c - omega*z*zeta*D(5) - 2*omega*zeta*Y(5)
MY(1,1) = (cgs_boltz*cgs_c*D(2) + cgs_c*cgs_mhydr*miu*omega**2*z - &
      cgs_mhydr*miu*((F(2,1) + F(2,2))*Y(1) + F(1,1) + F(1,2))*Y(4))/( &
      cgs_c*cgs_mhydr*miu)
MY(2,1) = 3*((F(2,1) + F(2,2))*Y(1) + F(1,1) + F(1,2))*Y(4)
MY(3,1) = alpha*cgs_boltz*omega*Y(2)/(cgs_mhydr*miu)
MY(4,1) = -alpha*cgs_boltz*omega*Y(2)/(cgs_mhydr*miu)
MY(1,2) = (cgs_boltz*cgs_c*D(1) - cgs_mhydr*miu*(F(3,1) + F(3,2))*Y(1)*Y &
      (4))/(cgs_c*cgs_mhydr*miu)
MY(2,2) = 3*(F(3,1) + F(3,2))*Y(1)*Y(4)
MY(3,2) = alpha*cgs_boltz*omega*Y(1)/(cgs_mhydr*miu)
MY(4,2) = -alpha*cgs_boltz*omega*Y(1)/(cgs_mhydr*miu)
MY(1,3) = 0
MY(2,3) = 48*cgs_stef*D(3)*Y(3)**2
MY(3,3) = (16.0d0/3.0d0)*alpha*cgs_stef*omega*Y(3)**3/cgs_c
MY(4,3) = -16.0d0/3.0d0*alpha*cgs_stef*omega*Y(3)**3/cgs_c
MY(1,4) = -(F(1,1) + F(1,2))*Y(1)/cgs_c
MY(2,4) = 3*(F(1,1) + F(1,2))*Y(1)
MY(3,4) = 0
MY(4,4) = 0
MY(1,5) = 0
MY(2,5) = 0
MY(3,5) = omega*(-2*alpha*nu + alpha - 2*zeta)
MY(4,5) = omega*(alpha*(nu - 1) + 2*zeta)
MD(1,1) = cgs_boltz*Y(2)/(cgs_mhydr*miu)
MD(2,1) = 0
MD(3,1) = 0
MD(4,1) = 0
MD(1,2) = cgs_boltz*Y(1)/(cgs_mhydr*miu)
MD(2,2) = 0
MD(3,2) = 0
MD(4,2) = 0
MD(1,3) = 0
MD(2,3) = 16*cgs_stef*Y(3)**3
MD(3,3) = 0
MD(4,3) = 0
MD(1,4) = 0
MD(2,4) = 0
MD(3,4) = 1
MD(4,4) = 0
MD(1,5) = 1
MD(2,5) = 0
MD(3,5) = 0
MD(4,5) = omega*z*zeta
end subroutine

pure subroutine mrx_coeff0_mw (z,Y,F,C,MC)
use iso_fortran_env, only: dp => real64
implicit none
real(dp), intent(in) :: z
real(dp), dimension(:), intent(in) :: Y
real(dp), dimension(:,:), intent(in) :: F
real(dp), dimension(:), intent(out) :: C
real(dp), dimension(:,:), intent(out) :: MC
C(1) = alpha*cgs_boltz*omega*Y(1)*Y(2)/(cgs_mhydr*miu) - 2*alpha*nu* &
      omega*Y(5) + alpha*omega*Y(5) + (4.0d0/3.0d0)*alpha*cgs_stef* &
      omega*Y(3)**4/cgs_c + 16*cgs_boltz*cgs_stef*F(1,2)*Y(1)*Y(2)*Y(3) &
      **4/(cgs_c**2*cgs_mel) - 16*cgs_boltz*cgs_stef*F(1,2)*Y(1)*Y(3)** &
      5/(cgs_c**2*cgs_mel) - 2*omega*zeta*Y(5)
MC(1,1) = -cgs_boltz*(alpha*cgs_c**2*cgs_mel*omega*Y(2) + 16*cgs_mhydr* &
      cgs_stef*miu*(F(1,2) + F(2,2)*Y(1))*(Y(2) - Y(3))*Y(3)**4)/(cgs_c &
      **2*cgs_mel*cgs_mhydr*miu)
MC(1,2) = -cgs_boltz*(alpha*cgs_c**2*cgs_mel*omega + 16*cgs_mhydr* &
      cgs_stef*miu*((Y(2) - Y(3))*F(3,2) + F(1,2))*Y(3)**4)*Y(1)/(cgs_c &
      **2*cgs_mel*cgs_mhydr*miu)
MC(1,3) = (16.0d0/3.0d0)*cgs_stef*(-alpha*cgs_c*cgs_mel*omega + 3* &
      cgs_boltz*(-4*Y(2) + 5*Y(3))*F(1,2)*Y(1))*Y(3)**3/(cgs_c**2* &
      cgs_mel)
MC(1,4) = 0
MC(1,5) = omega*(alpha*(2*nu - 1) + 2*zeta)
end subroutine

pure subroutine mrx_coeffbl_mw (z,Y,F,B,MB)
use iso_fortran_env, only: dp => real64
implicit none
real(dp), intent(in) :: z
real(dp), dimension(:), intent(in) :: Y
real(dp), dimension(:,:), intent(in) :: F
real(dp), dimension(:), intent(out) :: B
real(dp), dimension(:,:), intent(out) :: MB
B(1) = -Y(4)
B(2) = alpha*cgs_boltz*omega*Y(1)*Y(2)/(cgs_mhydr*miu) - alpha*nu*omega* &
      Y(5) + alpha*omega*Y(5) + (4.0d0/3.0d0)*alpha*cgs_stef*omega*Y(3) &
      **4/cgs_c - 2*omega*zeta*Y(5)
MB(1,1) = 0
MB(2,1) = -alpha*cgs_boltz*omega*Y(2)/(cgs_mhydr*miu)
MB(1,2) = 0
MB(2,2) = -alpha*cgs_boltz*omega*Y(1)/(cgs_mhydr*miu)
MB(1,3) = 0
MB(2,3) = -16.0d0/3.0d0*alpha*cgs_stef*omega*Y(3)**3/cgs_c
MB(1,4) = 1
MB(2,4) = 0
MB(1,5) = 0
MB(2,5) = omega*(alpha*(nu - 1) + 2*zeta)
end subroutine

pure subroutine mrx_coeffbr_mw (z,Y,F,B,MB)
use iso_fortran_env, only: dp => real64
implicit none
real(dp), intent(in) :: z
real(dp), dimension(:), intent(in) :: Y
real(dp), dimension(:,:), intent(in) :: F
real(dp), dimension(:), intent(out) :: B
real(dp), dimension(:,:), intent(out) :: MB
B(1) = facc - 2*omega*z*zeta*Y(5) - Y(4)
B(2) = 2*cgs_stef*Y(3)**4 - Y(4)
MB(1,1) = 0
MB(2,1) = 0
MB(1,2) = 0
MB(2,2) = 0
MB(1,3) = 0
MB(2,3) = -8*cgs_stef*Y(3)**3
MB(1,4) = 1
MB(2,4) = 1
MB(1,5) = 2*omega*z*zeta
MB(2,5) = 0
end subroutine

pure subroutine mrx_output_mw (z,Y,YY)
use iso_fortran_env, only: dp => real64
implicit none
real(dp), intent(in) :: z
real(dp), dimension(:), intent(in) :: Y
real(dp), dimension(:), intent(out) :: YY
YY(1) = Y(1)
YY(2) = Y(2)
YY(3) = Y(3)
YY(4) = cgs_boltz*Y(1)*Y(2)/(cgs_mhydr*miu)
YY(5) = (4.0d0/3.0d0)*cgs_stef*Y(3)**4/cgs_c
YY(6) = Y(5)
YY(7) = Y(4)
YY(8) = 2*omega*z*zeta*Y(5)
YY(9) = 0
YY(10) = -alpha*cgs_boltz*omega*Y(1)*Y(2)/(cgs_mhydr*miu) + 2*alpha*nu* &
      omega*Y(5) - alpha*omega*Y(5) - 4.0d0/3.0d0*alpha*cgs_stef*omega* &
      Y(3)**4/cgs_c + 2*omega*zeta*Y(5)
YY(11) = omega*z*zeta
end subroutine

!------------------------------------------------------------------------------!
! heating-cooling balance (full equation)
! magnetic heating
! no thermal conduction
pure subroutine mrx_coeff1_mc (z,Y,D,F,A,MY,MD)
use iso_fortran_env, only: dp => real64
implicit none
real(dp), intent(in) :: z
! first column: values, second column: 1ord derivatives
real(dp), dimension(:), intent(in) :: Y,D
! each row is one Function: its value and derivatives to rho and T
real(dp), dimension(:,:), intent(in) :: F
! right-hand-side of the equation
real(dp), dimension(:), intent(out) :: A
! jacobians with respect to Y and dY/dz
real(dp), dimension(:,:), intent(out) :: MY, MD
A(1) = (-cgs_boltz*cgs_c*(D(1)*Y(2) + D(2)*Y(1)) - cgs_c*cgs_mhydr*miu*( &
      omega**2*z*Y(1) + D(5)) + cgs_mhydr*miu*(F(1,1) + F(1,2))*Y(1)*Y( &
      4))/(cgs_c*cgs_mhydr*miu)
A(2) = -16*cgs_stef*D(3)*Y(3)**3 - 3*(F(1,1) + F(1,2))*Y(1)*Y(4)
A(3) = -alpha*cgs_boltz*omega*Y(1)*Y(2)/(cgs_mhydr*miu) + 2*alpha*nu* &
      omega*Y(5) - alpha*omega*Y(5) - 4.0d0/3.0d0*alpha*cgs_stef*omega* &
      Y(3)**4/cgs_c + 2*omega*zeta*Y(5) - D(4)
A(4) = alpha*cgs_boltz*omega*Y(1)*Y(2)/(cgs_mhydr*miu) - alpha*nu*omega* &
      Y(5) + alpha*omega*Y(5) + (4.0d0/3.0d0)*alpha*cgs_stef*omega*Y(3) &
      **4/cgs_c - omega*z*zeta*D(5) - 2*omega*zeta*Y(5)
MY(1,1) = (cgs_boltz*cgs_c*D(2) + cgs_c*cgs_mhydr*miu*omega**2*z - &
      cgs_mhydr*miu*((F(2,1) + F(2,2))*Y(1) + F(1,1) + F(1,2))*Y(4))/( &
      cgs_c*cgs_mhydr*miu)
MY(2,1) = 3*((F(2,1) + F(2,2))*Y(1) + F(1,1) + F(1,2))*Y(4)
MY(3,1) = alpha*cgs_boltz*omega*Y(2)/(cgs_mhydr*miu)
MY(4,1) = -alpha*cgs_boltz*omega*Y(2)/(cgs_mhydr*miu)
MY(1,2) = (cgs_boltz*cgs_c*D(1) - cgs_mhydr*miu*(F(3,1) + F(3,2))*Y(1)*Y &
      (4))/(cgs_c*cgs_mhydr*miu)
MY(2,2) = 3*(F(3,1) + F(3,2))*Y(1)*Y(4)
MY(3,2) = alpha*cgs_boltz*omega*Y(1)/(cgs_mhydr*miu)
MY(4,2) = -alpha*cgs_boltz*omega*Y(1)/(cgs_mhydr*miu)
MY(1,3) = 0
MY(2,3) = 48*cgs_stef*D(3)*Y(3)**2
MY(3,3) = (16.0d0/3.0d0)*alpha*cgs_stef*omega*Y(3)**3/cgs_c
MY(4,3) = -16.0d0/3.0d0*alpha*cgs_stef*omega*Y(3)**3/cgs_c
MY(1,4) = -(F(1,1) + F(1,2))*Y(1)/cgs_c
MY(2,4) = 3*(F(1,1) + F(1,2))*Y(1)
MY(3,4) = 0
MY(4,4) = 0
MY(1,5) = 0
MY(2,5) = 0
MY(3,5) = omega*(-2*alpha*nu + alpha - 2*zeta)
MY(4,5) = omega*(alpha*(nu - 1) + 2*zeta)
MD(1,1) = cgs_boltz*Y(2)/(cgs_mhydr*miu)
MD(2,1) = 0
MD(3,1) = 0
MD(4,1) = 0
MD(1,2) = cgs_boltz*Y(1)/(cgs_mhydr*miu)
MD(2,2) = 0
MD(3,2) = 0
MD(4,2) = 0
MD(1,3) = 0
MD(2,3) = 16*cgs_stef*Y(3)**3
MD(3,3) = 0
MD(4,3) = 0
MD(1,4) = 0
MD(2,4) = 0
MD(3,4) = 1
MD(4,4) = 0
MD(1,5) = 1
MD(2,5) = 0
MD(3,5) = 0
MD(4,5) = omega*z*zeta
end subroutine

pure subroutine mrx_coeff0_mc (z,Y,F,C,MC)
use iso_fortran_env, only: dp => real64
implicit none
real(dp), intent(in) :: z
real(dp), dimension(:), intent(in) :: Y
real(dp), dimension(:,:), intent(in) :: F
real(dp), dimension(:), intent(out) :: C
real(dp), dimension(:,:), intent(out) :: MC
C(1) = (1.0d0/3.0d0)*(alpha*cgs_c*cgs_mel*omega*(3*cgs_boltz*cgs_c*Y(1)* &
      Y(2) + 3*cgs_c*cgs_mhydr*miu*(-2*nu + 1)*Y(5) + 4*cgs_mhydr* &
      cgs_stef*miu*Y(3)**4) - 6*cgs_c**2*cgs_mel*cgs_mhydr*miu*omega* &
      zeta*Y(5) + 12*cgs_mhydr*cgs_stef*miu*(4*cgs_boltz*F(1,2)*Y(3)**4 &
      + cgs_c**2*cgs_mel*(Y(2) + Y(3))*(Y(2)**2 + Y(3)**2)*F(1,1))*(Y(2 &
      ) - Y(3))*Y(1))/(cgs_c**2*cgs_mel*cgs_mhydr*miu)
MC(1,1) = -(alpha*cgs_boltz*cgs_c**2*cgs_mel*omega*Y(2) + 4*cgs_mhydr* &
      cgs_stef*miu*(Y(2) - Y(3))*(4*cgs_boltz*F(1,2)*Y(3)**4 + cgs_c**2 &
      *cgs_mel*(Y(2) + Y(3))*(Y(2)**2 + Y(3)**2)*F(1,1) + (4*cgs_boltz* &
      F(2,2)*Y(3)**4 + cgs_c**2*cgs_mel*(Y(2) + Y(3))*(Y(2)**2 + Y(3)** &
      2)*F(2,1))*Y(1)))/(cgs_c**2*cgs_mel*cgs_mhydr*miu)
MC(1,2) = -alpha*cgs_boltz*omega*Y(1)/(cgs_mhydr*miu) - 16*cgs_boltz* &
      cgs_stef*F(1,2)*Y(1)*Y(3)**4/(cgs_c**2*cgs_mel) - 16*cgs_boltz* &
      cgs_stef*F(3,2)*Y(1)*Y(2)*Y(3)**4/(cgs_c**2*cgs_mel) + 16* &
      cgs_boltz*cgs_stef*F(3,2)*Y(1)*Y(3)**5/(cgs_c**2*cgs_mel) - 16* &
      cgs_stef*F(1,1)*Y(1)*Y(2)**3 - 4*cgs_stef*F(3,1)*Y(1)*Y(2)**4 + 4 &
      *cgs_stef*F(3,1)*Y(1)*Y(3)**4
MC(1,3) = (16.0d0/3.0d0)*cgs_stef*(-alpha*cgs_c*cgs_mel*omega - 12* &
      cgs_boltz*F(1,2)*Y(1)*Y(2) + 15*cgs_boltz*F(1,2)*Y(1)*Y(3) + 3* &
      cgs_c**2*cgs_mel*F(1,1)*Y(1))*Y(3)**3/(cgs_c**2*cgs_mel)
MC(1,4) = 0
MC(1,5) = omega*(alpha*(2*nu - 1) + 2*zeta)
end subroutine

pure subroutine mrx_coeffbl_mc (z,Y,F,B,MB)
use iso_fortran_env, only: dp => real64
implicit none
real(dp), intent(in) :: z
real(dp), dimension(:), intent(in) :: Y
real(dp), dimension(:,:), intent(in) :: F
real(dp), dimension(:), intent(out) :: B
real(dp), dimension(:,:), intent(out) :: MB
B(1) = -Y(4)
B(2) = alpha*cgs_boltz*omega*Y(1)*Y(2)/(cgs_mhydr*miu) - alpha*nu*omega* &
      Y(5) + alpha*omega*Y(5) + (4.0d0/3.0d0)*alpha*cgs_stef*omega*Y(3) &
      **4/cgs_c - 2*omega*zeta*Y(5)
MB(1,1) = 0
MB(2,1) = -alpha*cgs_boltz*omega*Y(2)/(cgs_mhydr*miu)
MB(1,2) = 0
MB(2,2) = -alpha*cgs_boltz*omega*Y(1)/(cgs_mhydr*miu)
MB(1,3) = 0
MB(2,3) = -16.0d0/3.0d0*alpha*cgs_stef*omega*Y(3)**3/cgs_c
MB(1,4) = 1
MB(2,4) = 0
MB(1,5) = 0
MB(2,5) = omega*(alpha*(nu - 1) + 2*zeta)
end subroutine

pure subroutine mrx_coeffbr_mc (z,Y,F,B,MB)
use iso_fortran_env, only: dp => real64
implicit none
real(dp), intent(in) :: z
real(dp), dimension(:), intent(in) :: Y
real(dp), dimension(:,:), intent(in) :: F
real(dp), dimension(:), intent(out) :: B
real(dp), dimension(:,:), intent(out) :: MB
B(1) = facc - 2*omega*z*zeta*Y(5) - Y(4)
B(2) = 2*cgs_stef*Y(3)**4 - Y(4)
MB(1,1) = 0
MB(2,1) = 0
MB(1,2) = 0
MB(2,2) = 0
MB(1,3) = 0
MB(2,3) = -8*cgs_stef*Y(3)**3
MB(1,4) = 1
MB(2,4) = 1
MB(1,5) = 2*omega*z*zeta
MB(2,5) = 0
end subroutine

pure subroutine mrx_output_mc (z,Y,YY)
use iso_fortran_env, only: dp => real64
implicit none
real(dp), intent(in) :: z
real(dp), dimension(:), intent(in) :: Y
real(dp), dimension(:), intent(out) :: YY
YY(1) = Y(1)
YY(2) = Y(2)
YY(3) = Y(3)
YY(4) = cgs_boltz*Y(1)*Y(2)/(cgs_mhydr*miu)
YY(5) = (4.0d0/3.0d0)*cgs_stef*Y(3)**4/cgs_c
YY(6) = Y(5)
YY(7) = Y(4)
YY(8) = 2*omega*z*zeta*Y(5)
YY(9) = 0
YY(10) = -alpha*cgs_boltz*omega*Y(1)*Y(2)/(cgs_mhydr*miu) + 2*alpha*nu* &
      omega*Y(5) - alpha*omega*Y(5) - 4.0d0/3.0d0*alpha*cgs_stef*omega* &
      Y(3)**4/cgs_c + 2*omega*zeta*Y(5)
YY(11) = omega*z*zeta
end subroutine

!------------------------------------------------------------------------------!
! heating-cooling balance (full equation)
! magnetic heating
! radiation + thermal conduction
pure subroutine mrx_coeff1_mct (z,Y,D,F,A,MY,MD)
use iso_fortran_env, only: dp => real64
implicit none
real(dp), intent(in) :: z
! first column: values, second column: 1ord derivatives
real(dp), dimension(:), intent(in) :: Y,D
! each row is one Function: its value and derivatives to rho and T
real(dp), dimension(:,:), intent(in) :: F
! right-hand-side of the equation
real(dp), dimension(:), intent(out) :: A
! jacobians with respect to Y and dY/dz
real(dp), dimension(:,:), intent(out) :: MY, MD
A(1) = (-cgs_boltz*cgs_c*(D(1)*Y(2) + D(2)*Y(1)) - cgs_c*cgs_mhydr*miu*( &
      omega**2*z*Y(1) + D(6)) + cgs_mhydr*miu*(F(1,1) + F(1,2))*Y(1)*Y( &
      4))/(cgs_c*cgs_mhydr*miu)
A(2) = -16*cgs_stef*D(3)*Y(3)**3 - 3*(F(1,1) + F(1,2))*Y(1)*Y(4)
A(3) = -alpha*cgs_boltz*omega*Y(1)*Y(2)/(cgs_mhydr*miu) + 2*alpha*nu* &
      omega*Y(6) - alpha*omega*Y(6) - 4.0d0/3.0d0*alpha*cgs_stef*omega* &
      Y(3)**4/cgs_c + 2*omega*zeta*Y(6) - D(4) - D(5)
A(4) = alpha*cgs_boltz*omega*Y(1)*Y(2)/(cgs_mhydr*miu) - alpha*nu*omega* &
      Y(6) + alpha*omega*Y(6) + (4.0d0/3.0d0)*alpha*cgs_stef*omega*Y(3) &
      **4/cgs_c - omega*z*zeta*D(6) - 2*omega*zeta*Y(6)
A(5) = (cgs_c**2*cgs_mel*D(4) - 4*cgs_stef*(4*cgs_boltz*F(1,2)*Y(3)**4 + &
      cgs_c**2*cgs_mel*(Y(2) + Y(3))*(Y(2)**2 + Y(3)**2)*F(1,1))*(Y(2) &
      - Y(3))*Y(1))/(cgs_c**2*cgs_mel)
A(6) = -D(2)*F(1,3) - Y(5)
MY(1,1) = (cgs_boltz*cgs_c*D(2) + cgs_c*cgs_mhydr*miu*omega**2*z - &
      cgs_mhydr*miu*((F(2,1) + F(2,2))*Y(1) + F(1,1) + F(1,2))*Y(4))/( &
      cgs_c*cgs_mhydr*miu)
MY(2,1) = 3*((F(2,1) + F(2,2))*Y(1) + F(1,1) + F(1,2))*Y(4)
MY(3,1) = alpha*cgs_boltz*omega*Y(2)/(cgs_mhydr*miu)
MY(4,1) = -alpha*cgs_boltz*omega*Y(2)/(cgs_mhydr*miu)
MY(5,1) = 4*cgs_stef*(Y(2) - Y(3))*(4*cgs_boltz*F(1,2)*Y(3)**4 + cgs_c** &
      2*cgs_mel*(Y(2) + Y(3))*(Y(2)**2 + Y(3)**2)*F(1,1) + (4*cgs_boltz &
      *F(2,2)*Y(3)**4 + cgs_c**2*cgs_mel*(Y(2) + Y(3))*(Y(2)**2 + Y(3) &
      **2)*F(2,1))*Y(1))/(cgs_c**2*cgs_mel)
MY(6,1) = D(2)*F(2,3)
MY(1,2) = (cgs_boltz*cgs_c*D(1) - cgs_mhydr*miu*(F(3,1) + F(3,2))*Y(1)*Y &
      (4))/(cgs_c*cgs_mhydr*miu)
MY(2,2) = 3*(F(3,1) + F(3,2))*Y(1)*Y(4)
MY(3,2) = alpha*cgs_boltz*omega*Y(1)/(cgs_mhydr*miu)
MY(4,2) = -alpha*cgs_boltz*omega*Y(1)/(cgs_mhydr*miu)
MY(5,2) = 4*cgs_stef*(4*cgs_boltz*F(1,2)*Y(3)**4 + 4*cgs_boltz*F(3,2)*Y( &
      2)*Y(3)**4 - 4*cgs_boltz*F(3,2)*Y(3)**5 + 4*cgs_c**2*cgs_mel*F(1, &
      1)*Y(2)**3 + cgs_c**2*cgs_mel*F(3,1)*Y(2)**4 - cgs_c**2*cgs_mel*F &
      (3,1)*Y(3)**4)*Y(1)/(cgs_c**2*cgs_mel)
MY(6,2) = D(2)*F(3,3)
MY(1,3) = 0
MY(2,3) = 48*cgs_stef*D(3)*Y(3)**2
MY(3,3) = (16.0d0/3.0d0)*alpha*cgs_stef*omega*Y(3)**3/cgs_c
MY(4,3) = -16.0d0/3.0d0*alpha*cgs_stef*omega*Y(3)**3/cgs_c
MY(5,3) = -16*cgs_stef*(-4*cgs_boltz*F(1,2)*Y(2) + 5*cgs_boltz*F(1,2)*Y( &
      3) + cgs_c**2*cgs_mel*F(1,1))*Y(1)*Y(3)**3/(cgs_c**2*cgs_mel)
MY(6,3) = 0
MY(1,4) = -(F(1,1) + F(1,2))*Y(1)/cgs_c
MY(2,4) = 3*(F(1,1) + F(1,2))*Y(1)
MY(3,4) = 0
MY(4,4) = 0
MY(5,4) = 0
MY(6,4) = 0
MY(1,5) = 0
MY(2,5) = 0
MY(3,5) = 0
MY(4,5) = 0
MY(5,5) = 0
MY(6,5) = 1
MY(1,6) = 0
MY(2,6) = 0
MY(3,6) = omega*(-2*alpha*nu + alpha - 2*zeta)
MY(4,6) = omega*(alpha*(nu - 1) + 2*zeta)
MY(5,6) = 0
MY(6,6) = 0
MD(1,1) = cgs_boltz*Y(2)/(cgs_mhydr*miu)
MD(2,1) = 0
MD(3,1) = 0
MD(4,1) = 0
MD(5,1) = 0
MD(6,1) = 0
MD(1,2) = cgs_boltz*Y(1)/(cgs_mhydr*miu)
MD(2,2) = 0
MD(3,2) = 0
MD(4,2) = 0
MD(5,2) = 0
MD(6,2) = F(1,3)
MD(1,3) = 0
MD(2,3) = 16*cgs_stef*Y(3)**3
MD(3,3) = 0
MD(4,3) = 0
MD(5,3) = 0
MD(6,3) = 0
MD(1,4) = 0
MD(2,4) = 0
MD(3,4) = 1
MD(4,4) = 0
MD(5,4) = -1
MD(6,4) = 0
MD(1,5) = 0
MD(2,5) = 0
MD(3,5) = 1
MD(4,5) = 0
MD(5,5) = 0
MD(6,5) = 0
MD(1,6) = 1
MD(2,6) = 0
MD(3,6) = 0
MD(4,6) = omega*z*zeta
MD(5,6) = 0
MD(6,6) = 0
end subroutine

pure subroutine mrx_coeffbl_mct (z,Y,F,B,MB)
use iso_fortran_env, only: dp => real64
implicit none
real(dp), intent(in) :: z
real(dp), dimension(:), intent(in) :: Y
real(dp), dimension(:,:), intent(in) :: F
real(dp), dimension(:), intent(out) :: B
real(dp), dimension(:,:), intent(out) :: MB
B(1) = -Y(4)
B(2) = alpha*cgs_boltz*omega*Y(1)*Y(2)/(cgs_mhydr*miu) - alpha*nu*omega* &
      Y(6) + alpha*omega*Y(6) + (4.0d0/3.0d0)*alpha*cgs_stef*omega*Y(3) &
      **4/cgs_c - 2*omega*zeta*Y(6)
B(3) = -Y(2) + Y(3)
B(4) = -Y(5)
MB(1,1) = 0
MB(2,1) = -alpha*cgs_boltz*omega*Y(2)/(cgs_mhydr*miu)
MB(3,1) = 0
MB(4,1) = 0
MB(1,2) = 0
MB(2,2) = -alpha*cgs_boltz*omega*Y(1)/(cgs_mhydr*miu)
MB(3,2) = 1
MB(4,2) = 0
MB(1,3) = 0
MB(2,3) = -16.0d0/3.0d0*alpha*cgs_stef*omega*Y(3)**3/cgs_c
MB(3,3) = -1
MB(4,3) = 0
MB(1,4) = 1
MB(2,4) = 0
MB(3,4) = 0
MB(4,4) = 0
MB(1,5) = 0
MB(2,5) = 0
MB(3,5) = 0
MB(4,5) = 1
MB(1,6) = 0
MB(2,6) = omega*(alpha*(nu - 1) + 2*zeta)
MB(3,6) = 0
MB(4,6) = 0
end subroutine

pure subroutine mrx_coeffbr_mct (z,Y,F,B,MB)
use iso_fortran_env, only: dp => real64
implicit none
real(dp), intent(in) :: z
real(dp), dimension(:), intent(in) :: Y
real(dp), dimension(:,:), intent(in) :: F
real(dp), dimension(:), intent(out) :: B
real(dp), dimension(:,:), intent(out) :: MB
B(1) = facc - 2*omega*z*zeta*Y(6) - Y(4) - Y(5)
B(2) = 2*cgs_stef*Y(3)**4 - Y(4)
MB(1,1) = 0
MB(2,1) = 0
MB(1,2) = 0
MB(2,2) = 0
MB(1,3) = 0
MB(2,3) = -8*cgs_stef*Y(3)**3
MB(1,4) = 1
MB(2,4) = 1
MB(1,5) = 1
MB(2,5) = 0
MB(1,6) = 2*omega*z*zeta
MB(2,6) = 0
end subroutine

pure subroutine mrx_output_mct (z,Y,YY)
use iso_fortran_env, only: dp => real64
implicit none
real(dp), intent(in) :: z
real(dp), dimension(:), intent(in) :: Y
real(dp), dimension(:), intent(out) :: YY
YY(1) = Y(1)
YY(2) = Y(2)
YY(3) = Y(3)
YY(4) = cgs_boltz*Y(1)*Y(2)/(cgs_mhydr*miu)
YY(5) = (4.0d0/3.0d0)*cgs_stef*Y(3)**4/cgs_c
YY(6) = Y(6)
YY(7) = Y(4)
YY(8) = 2*omega*z*zeta*Y(6)
YY(9) = Y(5)
YY(10) = -alpha*cgs_boltz*omega*Y(1)*Y(2)/(cgs_mhydr*miu) + 2*alpha*nu* &
      omega*Y(6) - alpha*omega*Y(6) - 4.0d0/3.0d0*alpha*cgs_stef*omega* &
      Y(3)**4/cgs_c + 2*omega*zeta*Y(6)
YY(11) = omega*z*zeta
end subroutine

!------------------------------------------------------------------------------!
! heating-cooling balance (compton term only)
! magnetic heating
! radiation + thermal conduction
pure subroutine mrx_coeff1_mwt (z,Y,D,F,A,MY,MD)
use iso_fortran_env, only: dp => real64
implicit none
real(dp), intent(in) :: z
! first column: values, second column: 1ord derivatives
real(dp), dimension(:), intent(in) :: Y,D
! each row is one Function: its value and derivatives to rho and T
real(dp), dimension(:,:), intent(in) :: F
! right-hand-side of the equation
real(dp), dimension(:), intent(out) :: A
! jacobians with respect to Y and dY/dz
real(dp), dimension(:,:), intent(out) :: MY, MD
A(1) = (-cgs_boltz*cgs_c*(D(1)*Y(2) + D(2)*Y(1)) - cgs_c*cgs_mhydr*miu*( &
      omega**2*z*Y(1) + D(6)) + cgs_mhydr*miu*(F(1,1) + F(1,2))*Y(1)*Y( &
      4))/(cgs_c*cgs_mhydr*miu)
A(2) = -16*cgs_stef*D(3)*Y(3)**3 - 3*(F(1,1) + F(1,2))*Y(1)*Y(4)
A(3) = -alpha*cgs_boltz*omega*Y(1)*Y(2)/(cgs_mhydr*miu) + 2*alpha*nu* &
      omega*Y(6) - alpha*omega*Y(6) - 4.0d0/3.0d0*alpha*cgs_stef*omega* &
      Y(3)**4/cgs_c + 2*omega*zeta*Y(6) - D(4) - D(5)
A(4) = alpha*cgs_boltz*omega*Y(1)*Y(2)/(cgs_mhydr*miu) - alpha*nu*omega* &
      Y(6) + alpha*omega*Y(6) + (4.0d0/3.0d0)*alpha*cgs_stef*omega*Y(3) &
      **4/cgs_c - omega*z*zeta*D(6) - 2*omega*zeta*Y(6)
A(5) = (-16*cgs_boltz*cgs_stef*(Y(2) - Y(3))*F(1,2)*Y(1)*Y(3)**4 + cgs_c &
      **2*cgs_mel*D(4))/(cgs_c**2*cgs_mel)
A(6) = -D(2)*F(1,3) - Y(5)
MY(1,1) = (cgs_boltz*cgs_c*D(2) + cgs_c*cgs_mhydr*miu*omega**2*z - &
      cgs_mhydr*miu*((F(2,1) + F(2,2))*Y(1) + F(1,1) + F(1,2))*Y(4))/( &
      cgs_c*cgs_mhydr*miu)
MY(2,1) = 3*((F(2,1) + F(2,2))*Y(1) + F(1,1) + F(1,2))*Y(4)
MY(3,1) = alpha*cgs_boltz*omega*Y(2)/(cgs_mhydr*miu)
MY(4,1) = -alpha*cgs_boltz*omega*Y(2)/(cgs_mhydr*miu)
MY(5,1) = 16*cgs_boltz*cgs_stef*(F(1,2) + F(2,2)*Y(1))*(Y(2) - Y(3))*Y(3 &
      )**4/(cgs_c**2*cgs_mel)
MY(6,1) = D(2)*F(2,3)
MY(1,2) = (cgs_boltz*cgs_c*D(1) - cgs_mhydr*miu*(F(3,1) + F(3,2))*Y(1)*Y &
      (4))/(cgs_c*cgs_mhydr*miu)
MY(2,2) = 3*(F(3,1) + F(3,2))*Y(1)*Y(4)
MY(3,2) = alpha*cgs_boltz*omega*Y(1)/(cgs_mhydr*miu)
MY(4,2) = -alpha*cgs_boltz*omega*Y(1)/(cgs_mhydr*miu)
MY(5,2) = 16*cgs_boltz*cgs_stef*((Y(2) - Y(3))*F(3,2) + F(1,2))*Y(1)*Y(3 &
      )**4/(cgs_c**2*cgs_mel)
MY(6,2) = D(2)*F(3,3)
MY(1,3) = 0
MY(2,3) = 48*cgs_stef*D(3)*Y(3)**2
MY(3,3) = (16.0d0/3.0d0)*alpha*cgs_stef*omega*Y(3)**3/cgs_c
MY(4,3) = -16.0d0/3.0d0*alpha*cgs_stef*omega*Y(3)**3/cgs_c
MY(5,3) = 16*cgs_boltz*cgs_stef*(4*Y(2) - 5*Y(3))*F(1,2)*Y(1)*Y(3)**3/( &
      cgs_c**2*cgs_mel)
MY(6,3) = 0
MY(1,4) = -(F(1,1) + F(1,2))*Y(1)/cgs_c
MY(2,4) = 3*(F(1,1) + F(1,2))*Y(1)
MY(3,4) = 0
MY(4,4) = 0
MY(5,4) = 0
MY(6,4) = 0
MY(1,5) = 0
MY(2,5) = 0
MY(3,5) = 0
MY(4,5) = 0
MY(5,5) = 0
MY(6,5) = 1
MY(1,6) = 0
MY(2,6) = 0
MY(3,6) = omega*(-2*alpha*nu + alpha - 2*zeta)
MY(4,6) = omega*(alpha*(nu - 1) + 2*zeta)
MY(5,6) = 0
MY(6,6) = 0
MD(1,1) = cgs_boltz*Y(2)/(cgs_mhydr*miu)
MD(2,1) = 0
MD(3,1) = 0
MD(4,1) = 0
MD(5,1) = 0
MD(6,1) = 0
MD(1,2) = cgs_boltz*Y(1)/(cgs_mhydr*miu)
MD(2,2) = 0
MD(3,2) = 0
MD(4,2) = 0
MD(5,2) = 0
MD(6,2) = F(1,3)
MD(1,3) = 0
MD(2,3) = 16*cgs_stef*Y(3)**3
MD(3,3) = 0
MD(4,3) = 0
MD(5,3) = 0
MD(6,3) = 0
MD(1,4) = 0
MD(2,4) = 0
MD(3,4) = 1
MD(4,4) = 0
MD(5,4) = -1
MD(6,4) = 0
MD(1,5) = 0
MD(2,5) = 0
MD(3,5) = 1
MD(4,5) = 0
MD(5,5) = 0
MD(6,5) = 0
MD(1,6) = 1
MD(2,6) = 0
MD(3,6) = 0
MD(4,6) = omega*z*zeta
MD(5,6) = 0
MD(6,6) = 0
end subroutine

pure subroutine mrx_coeffbl_mwt (z,Y,F,B,MB)
use iso_fortran_env, only: dp => real64
implicit none
real(dp), intent(in) :: z
real(dp), dimension(:), intent(in) :: Y
real(dp), dimension(:,:), intent(in) :: F
real(dp), dimension(:), intent(out) :: B
real(dp), dimension(:,:), intent(out) :: MB
B(1) = -Y(4)
B(2) = alpha*cgs_boltz*omega*Y(1)*Y(2)/(cgs_mhydr*miu) - alpha*nu*omega* &
      Y(6) + alpha*omega*Y(6) + (4.0d0/3.0d0)*alpha*cgs_stef*omega*Y(3) &
      **4/cgs_c - 2*omega*zeta*Y(6)
B(3) = -Y(2) + Y(3)
B(4) = -Y(5)
MB(1,1) = 0
MB(2,1) = -alpha*cgs_boltz*omega*Y(2)/(cgs_mhydr*miu)
MB(3,1) = 0
MB(4,1) = 0
MB(1,2) = 0
MB(2,2) = -alpha*cgs_boltz*omega*Y(1)/(cgs_mhydr*miu)
MB(3,2) = 1
MB(4,2) = 0
MB(1,3) = 0
MB(2,3) = -16.0d0/3.0d0*alpha*cgs_stef*omega*Y(3)**3/cgs_c
MB(3,3) = -1
MB(4,3) = 0
MB(1,4) = 1
MB(2,4) = 0
MB(3,4) = 0
MB(4,4) = 0
MB(1,5) = 0
MB(2,5) = 0
MB(3,5) = 0
MB(4,5) = 1
MB(1,6) = 0
MB(2,6) = omega*(alpha*(nu - 1) + 2*zeta)
MB(3,6) = 0
MB(4,6) = 0
end subroutine

pure subroutine mrx_coeffbr_mwt (z,Y,F,B,MB)
use iso_fortran_env, only: dp => real64
implicit none
real(dp), intent(in) :: z
real(dp), dimension(:), intent(in) :: Y
real(dp), dimension(:,:), intent(in) :: F
real(dp), dimension(:), intent(out) :: B
real(dp), dimension(:,:), intent(out) :: MB
B(1) = facc - 2*omega*z*zeta*Y(6) - Y(4) - Y(5)
B(2) = 2*cgs_stef*Y(3)**4 - Y(4)
MB(1,1) = 0
MB(2,1) = 0
MB(1,2) = 0
MB(2,2) = 0
MB(1,3) = 0
MB(2,3) = -8*cgs_stef*Y(3)**3
MB(1,4) = 1
MB(2,4) = 1
MB(1,5) = 1
MB(2,5) = 0
MB(1,6) = 2*omega*z*zeta
MB(2,6) = 0
end subroutine

pure subroutine mrx_output_mwt (z,Y,YY)
use iso_fortran_env, only: dp => real64
implicit none
real(dp), intent(in) :: z
real(dp), dimension(:), intent(in) :: Y
real(dp), dimension(:), intent(out) :: YY
YY(1) = Y(1)
YY(2) = Y(2)
YY(3) = Y(3)
YY(4) = cgs_boltz*Y(1)*Y(2)/(cgs_mhydr*miu)
YY(5) = (4.0d0/3.0d0)*cgs_stef*Y(3)**4/cgs_c
YY(6) = Y(6)
YY(7) = Y(4)
YY(8) = 2*omega*z*zeta*Y(6)
YY(9) = Y(5)
YY(10) = -alpha*cgs_boltz*omega*Y(1)*Y(2)/(cgs_mhydr*miu) + 2*alpha*nu* &
      omega*Y(6) - alpha*omega*Y(6) - 4.0d0/3.0d0*alpha*cgs_stef*omega* &
      Y(3)**4/cgs_c + 2*omega*zeta*Y(6)
YY(11) = omega*z*zeta
end subroutine

