
!------------------------------------------------------------------------------!
! thermal diffusion
! alpha prescription
! radiative energy transport
!------------------------------------------------------------------------------!

pure subroutine mrx_coeffalphdyfu (z,Y,D,F,A,MY,MD)
use iso_fortran_env, only: real64
implicit none
real(real64), intent(in) :: z
! first column: values, second column: 1ord derivatives
real(real64), dimension(:), intent(in) :: Y,D
! each row is one function: its value and derivatives to rho and T
real(real64), dimension(:,:), intent(in) :: F
! right-hand-side of the equation
real(real64), dimension(:), intent(out) :: A
! jacobians with respect to Y and dY/dz
real(real64), dimension(:,:), intent(out) :: MY, MD
A(1) = (-cgs_boltz*cgs_c*(D(2)*Y(1) + Y(2)*D(1)) - cgs_c*cgs_mhydr*miu* &
   &   omega**2*z*Y(1) + cgs_mhydr*miu*Y(3)*(F(1,1) + F(1,2))*Y(1))/( &
   &   cgs_c*cgs_mhydr*miu)
A(2) = -1.0/(F(1,1) + F(1,2))*1.0/Y(1)*((16.0d0/3.0d0)*cgs_stef*Y(2)**3* &
   &   D(2) + Y(3)*(F(1,1) + F(1,2))*Y(1))
A(3) = alpha*cgs_boltz*omega*Y(2)*Y(1)/(cgs_mhydr*miu) + (4.0d0/3.0d0)* &
   &   alpha*cgs_stef*omega*Y(2)**4/cgs_c - D(3)
MY(1,1) = (cgs_boltz*cgs_c*D(2) + cgs_c*cgs_mhydr*miu*omega**2*z - &
   &   cgs_mhydr*miu*Y(3)*((F(2,1) + F(2,2))*Y(1) + F(1,1) + F(1,2)))/( &
   &   cgs_c*cgs_mhydr*miu)
MY(2,1) = -16.0d0/3.0d0*cgs_stef*Y(2)**3*D(2)*(F(1,1) + F(1,2))**(-2)*Y( &
   &   1)**(-2)*((F(2,1) + F(2,2))*Y(1) + F(1,1) + F(1,2))
MY(3,1) = -alpha*cgs_boltz*omega*Y(2)/(cgs_mhydr*miu)
MY(1,2) = (cgs_boltz*cgs_c*D(1) - cgs_mhydr*miu*Y(3)*(F(3,1) + F(3,2))*Y &
   &   (1))/(cgs_c*cgs_mhydr*miu)
MY(2,2) = (16.0d0/3.0d0)*cgs_stef*Y(2)**2*D(2)*(F(1,1) + F(1,2))**(-2)* &
   &   1.0/Y(1)*(3*F(1,1) + 3*F(1,2) - Y(2)*(F(3,1) + F(3,2)))
MY(3,2) = -alpha*cgs_boltz*omega*Y(1)/(cgs_mhydr*miu) - 16.0d0/3.0d0* &
   &   alpha*cgs_stef*omega*Y(2)**3/cgs_c
MY(1,3) = -(F(1,1) + F(1,2))*Y(1)/cgs_c
MY(2,3) = 1
MY(3,3) = 0
MD(1,1) = cgs_boltz*Y(2)/(cgs_mhydr*miu)
MD(2,1) = 0
MD(3,1) = 0
MD(1,2) = cgs_boltz*Y(1)/(cgs_mhydr*miu)
MD(2,2) = (16.0d0/3.0d0)*cgs_stef*Y(2)**3*1.0/(F(1,1) + F(1,2))*1.0/Y(1)
MD(3,2) = 0
MD(1,3) = 0
MD(2,3) = 0
MD(3,3) = 1
end subroutine

pure subroutine mrx_coeffalphdyfu_bl (z,Y,F,B,MB)
use iso_fortran_env, only: real64
implicit none
real(real64), intent(in) :: z
real(real64), dimension(:), intent(in) :: Y
real(real64), dimension(:,:), intent(in) :: F
real(real64), dimension(:), intent(out) :: B
real(real64), dimension(:,:), intent(out) :: MB
B(1) = -Y(3)
MB(1,1) = 0
MB(1,2) = 0
MB(1,3) = 1
end subroutine

pure subroutine mrx_coeffalphdyfu_br (z,Y,F,B,MB)
use iso_fortran_env, only: real64
implicit none
real(real64), intent(in) :: z
real(real64), dimension(:), intent(in) :: Y
real(real64), dimension(:,:), intent(in) :: F
real(real64), dimension(:), intent(out) :: B
real(real64), dimension(:,:), intent(out) :: MB
B(1) = facc - Y(3)
B(2) = 2*cgs_stef*Y(2)**4 - Y(3)
MB(1,1) = 0
MB(2,1) = 0
MB(1,2) = 0
MB(2,2) = -8*cgs_stef*Y(2)**3
MB(1,3) = 1
MB(2,3) = 1
end subroutine



!------------------------------------------------------------------------------!
! heating-cooling balance
! alpha prescription
! radiative energy transport
!------------------------------------------------------------------------------!

pure subroutine mrx_coeffalphcmpt (z,Y,D,F,A,MY,MD)
use iso_fortran_env, only: real64
implicit none
real(real64), intent(in) :: z
! first column: values, second column: 1ord derivatives
real(real64), dimension(:), intent(in) :: Y,D
! each row is one function: its value and derivatives to rho and T
real(real64), dimension(:,:), intent(in) :: F
! right-hand-side of the equation
real(real64), dimension(:), intent(out) :: A
! jacobians with respect to Y and dY/dz
real(real64), dimension(:,:), intent(out) :: MY, MD
A(1) = (-cgs_boltz*cgs_c*(D(2)*Y(1) + Y(2)*D(1)) - cgs_c*cgs_mhydr*miu* &
   &   omega**2*z*Y(1) + cgs_mhydr*miu*Y(3)*(F(1,1) + F(1,3))*Y(1))/( &
   &   cgs_c*cgs_mhydr*miu)
A(2) = -1.0/(F(1,1) + F(1,3))*1.0/Y(1)*((16.0d0/3.0d0)*cgs_stef*Y(4)**3* &
   &   D(4) + Y(3)*(F(1,1) + F(1,3))*Y(1))
A(3) = alpha*cgs_boltz*omega*Y(2)*Y(1)/(cgs_mhydr*miu) + (4.0d0/3.0d0)* &
   &   alpha*cgs_stef*omega*Y(4)**4/cgs_c - D(3)
A(4) = Y(2)*(cgs_c**2*cgs_mel*D(3) - 4*cgs_stef*(Y(2) - Y(4))*(4* &
   &   cgs_boltz*F(1,1)*Y(4)**4 + cgs_c**2*cgs_mel*F(1,3)*(Y(2)**2 + Y(4 &
   &   )**2)*(Y(2) + Y(4)))*Y(1))/(cgs_c**2*cgs_mel)
MY(1,1) = (cgs_boltz*cgs_c*D(2) + cgs_c*cgs_mhydr*miu*omega**2*z - &
   &   cgs_mhydr*miu*Y(3)*((F(2,1) + F(2,3))*Y(1) + F(1,1) + F(1,3)))/( &
   &   cgs_c*cgs_mhydr*miu)
MY(2,1) = -16.0d0/3.0d0*cgs_stef*Y(4)**3*D(4)*(F(1,1) + F(1,3))**(-2)*Y( &
   &   1)**(-2)*((F(2,1) + F(2,3))*Y(1) + F(1,1) + F(1,3))
MY(3,1) = -alpha*cgs_boltz*omega*Y(2)/(cgs_mhydr*miu)
MY(4,1) = 4*cgs_stef*(Y(2) - Y(4))*Y(2)*(4*cgs_boltz*F(1,1)*Y(4)**4 + &
   &   cgs_c**2*cgs_mel*F(1,3)*(Y(2)**2 + Y(4)**2)*(Y(2) + Y(4)) + (4* &
   &   cgs_boltz*F(2,1)*Y(4)**4 + cgs_c**2*cgs_mel*F(2,3)*(Y(2)**2 + Y(4 &
   &   )**2)*(Y(2) + Y(4)))*Y(1))/(cgs_c**2*cgs_mel)
MY(1,2) = (cgs_boltz*cgs_c*D(1) - cgs_mhydr*miu*Y(3)*(F(3,1) + F(3,3))*Y &
   &   (1))/(cgs_c*cgs_mhydr*miu)
MY(2,2) = -16.0d0/3.0d0*cgs_stef*Y(4)**3*D(4)*(F(1,1) + F(1,3))**(-2)* &
   &   1.0/Y(1)*(F(3,1) + F(3,3))
MY(3,2) = -alpha*cgs_boltz*omega*Y(1)/(cgs_mhydr*miu)
MY(4,2) = 32*cgs_boltz*cgs_stef*F(1,1)*Y(4)**4*Y(2)*Y(1)/(cgs_c**2* &
   &   cgs_mel) - 16*cgs_boltz*cgs_stef*F(1,1)*Y(4)**5*Y(1)/(cgs_c**2* &
   &   cgs_mel) + 16*cgs_boltz*cgs_stef*F(3,1)*Y(4)**4*Y(2)**2*Y(1)/( &
   &   cgs_c**2*cgs_mel) - 16*cgs_boltz*cgs_stef*F(3,1)*Y(4)**5*Y(2)*Y(1 &
   &   )/(cgs_c**2*cgs_mel) + 20*cgs_stef*F(1,3)*Y(2)**4*Y(1) - 4* &
   &   cgs_stef*F(1,3)*Y(4)**4*Y(1) + 4*cgs_stef*F(3,3)*Y(2)**5*Y(1) - 4 &
   &   *cgs_stef*F(3,3)*Y(4)**4*Y(2)*Y(1) - D(3)
MY(1,3) = -(F(1,1) + F(1,3))*Y(1)/cgs_c
MY(2,3) = 1
MY(3,3) = 0
MY(4,3) = 0
MY(1,4) = 0
MY(2,4) = 16*cgs_stef*Y(4)**2*D(4)*1.0/(F(1,1) + F(1,3))*1.0/Y(1)
MY(3,4) = -16.0d0/3.0d0*alpha*cgs_stef*omega*Y(4)**3/cgs_c
MY(4,4) = -16*cgs_stef*Y(4)**3*Y(2)*(-4*cgs_boltz*F(1,1)*Y(2) + 5* &
   &   cgs_boltz*F(1,1)*Y(4) + cgs_c**2*cgs_mel*F(1,3))*Y(1)/(cgs_c**2* &
   &   cgs_mel)
MD(1,1) = cgs_boltz*Y(2)/(cgs_mhydr*miu)
MD(2,1) = 0
MD(3,1) = 0
MD(4,1) = 0
MD(1,2) = cgs_boltz*Y(1)/(cgs_mhydr*miu)
MD(2,2) = 0
MD(3,2) = 0
MD(4,2) = 0
MD(1,3) = 0
MD(2,3) = 0
MD(3,3) = 1
MD(4,3) = -Y(2)
MD(1,4) = 0
MD(2,4) = (16.0d0/3.0d0)*cgs_stef*Y(4)**3*1.0/(F(1,1) + F(1,3))*1.0/Y(1)
MD(3,4) = 0
MD(4,4) = 0
end subroutine

pure subroutine mrx_coeffalphcmpt_bl (z,Y,F,B,MB)
use iso_fortran_env, only: real64
implicit none
real(real64), intent(in) :: z
real(real64), dimension(:), intent(in) :: Y
real(real64), dimension(:,:), intent(in) :: F
real(real64), dimension(:), intent(out) :: B
real(real64), dimension(:,:), intent(out) :: MB
B(1) = -Y(3)
B(2) = -Y(2) + Y(4)
MB(1,1) = 0
MB(2,1) = 0
MB(1,2) = 0
MB(2,2) = 1
MB(1,3) = 1
MB(2,3) = 0
MB(1,4) = 0
MB(2,4) = -1
end subroutine

pure subroutine mrx_coeffalphcmpt_br (z,Y,F,B,MB)
use iso_fortran_env, only: real64
implicit none
real(real64), intent(in) :: z
real(real64), dimension(:), intent(in) :: Y
real(real64), dimension(:,:), intent(in) :: F
real(real64), dimension(:), intent(out) :: B
real(real64), dimension(:,:), intent(out) :: MB
B(1) = facc - Y(3)
B(2) = 2*cgs_stef*Y(4)**4 - Y(3)
MB(1,1) = 0
MB(2,1) = 0
MB(1,2) = 0
MB(2,2) = 0
MB(1,3) = 1
MB(2,3) = 1
MB(1,4) = 0
MB(2,4) = -8*cgs_stef*Y(4)**3
end subroutine



!------------------------------------------------------------------------------!
! thermal diffusion
! magnetic heating
! radiative energy transport
!------------------------------------------------------------------------------!

pure subroutine mrx_coeffmagndyfu (z,Y,D,F,A,MY,MD)
use iso_fortran_env, only: real64
implicit none
real(real64), intent(in) :: z
! first column: values, second column: 1ord derivatives
real(real64), dimension(:), intent(in) :: Y,D
! each row is one function: its value and derivatives to rho and T
real(real64), dimension(:,:), intent(in) :: F
! right-hand-side of the equation
real(real64), dimension(:), intent(out) :: A
! jacobians with respect to Y and dY/dz
real(real64), dimension(:,:), intent(out) :: MY, MD
A(1) = (-cgs_boltz*cgs_c*(D(2)*Y(1) + Y(2)*D(1)) - cgs_c*cgs_mhydr*miu*( &
   &   omega**2*z*Y(1) + D(4)) + cgs_mhydr*miu*Y(3)*(F(1,1) + F(1,2))*Y( &
   &   1))/(cgs_c*cgs_mhydr*miu)
A(2) = -1.0/(F(1,1) + F(1,2))*1.0/Y(1)*((16.0d0/3.0d0)*cgs_stef*Y(2)**3* &
   &   D(2) + Y(3)*(F(1,1) + F(1,2))*Y(1))
A(3) = -alpha*cgs_boltz*omega*Y(2)*Y(1)/(cgs_mhydr*miu) - alpha*omega*Y( &
   &   4) - 4.0d0/3.0d0*alpha*cgs_stef*omega*Y(2)**4/cgs_c + 2*omega* &
   &   zeta*Y(4) - D(3)
A(4) = alpha*cgs_boltz*omega*Y(2)*Y(1)/(cgs_mhydr*miu) + alpha*omega*Y(4 &
   &   ) + (4.0d0/3.0d0)*alpha*cgs_stef*omega*Y(2)**4/cgs_c - omega*z* &
   &   zeta*D(4) - 2*omega*zeta*Y(4)
MY(1,1) = (cgs_boltz*cgs_c*D(2) + cgs_c*cgs_mhydr*miu*omega**2*z - &
   &   cgs_mhydr*miu*Y(3)*((F(2,1) + F(2,2))*Y(1) + F(1,1) + F(1,2)))/( &
   &   cgs_c*cgs_mhydr*miu)
MY(2,1) = -16.0d0/3.0d0*cgs_stef*Y(2)**3*D(2)*(F(1,1) + F(1,2))**(-2)*Y( &
   &   1)**(-2)*((F(2,1) + F(2,2))*Y(1) + F(1,1) + F(1,2))
MY(3,1) = alpha*cgs_boltz*omega*Y(2)/(cgs_mhydr*miu)
MY(4,1) = -alpha*cgs_boltz*omega*Y(2)/(cgs_mhydr*miu)
MY(1,2) = (cgs_boltz*cgs_c*D(1) - cgs_mhydr*miu*Y(3)*(F(3,1) + F(3,2))*Y &
   &   (1))/(cgs_c*cgs_mhydr*miu)
MY(2,2) = (16.0d0/3.0d0)*cgs_stef*Y(2)**2*D(2)*(F(1,1) + F(1,2))**(-2)* &
   &   1.0/Y(1)*(3*F(1,1) + 3*F(1,2) - Y(2)*(F(3,1) + F(3,2)))
MY(3,2) = alpha*cgs_boltz*omega*Y(1)/(cgs_mhydr*miu) + (16.0d0/3.0d0)* &
   &   alpha*cgs_stef*omega*Y(2)**3/cgs_c
MY(4,2) = -alpha*cgs_boltz*omega*Y(1)/(cgs_mhydr*miu) - 16.0d0/3.0d0* &
   &   alpha*cgs_stef*omega*Y(2)**3/cgs_c
MY(1,3) = -(F(1,1) + F(1,2))*Y(1)/cgs_c
MY(2,3) = 1
MY(3,3) = 0
MY(4,3) = 0
MY(1,4) = 0
MY(2,4) = 0
MY(3,4) = omega*(alpha - 2*zeta)
MY(4,4) = omega*(-alpha + 2*zeta)
MD(1,1) = cgs_boltz*Y(2)/(cgs_mhydr*miu)
MD(2,1) = 0
MD(3,1) = 0
MD(4,1) = 0
MD(1,2) = cgs_boltz*Y(1)/(cgs_mhydr*miu)
MD(2,2) = (16.0d0/3.0d0)*cgs_stef*Y(2)**3*1.0/(F(1,1) + F(1,2))*1.0/Y(1)
MD(3,2) = 0
MD(4,2) = 0
MD(1,3) = 0
MD(2,3) = 0
MD(3,3) = 1
MD(4,3) = 0
MD(1,4) = 1
MD(2,4) = 0
MD(3,4) = 0
MD(4,4) = omega*z*zeta
end subroutine

pure subroutine mrx_coeffmagndyfu_bl (z,Y,F,B,MB)
use iso_fortran_env, only: real64
implicit none
real(real64), intent(in) :: z
real(real64), dimension(:), intent(in) :: Y
real(real64), dimension(:,:), intent(in) :: F
real(real64), dimension(:), intent(out) :: B
real(real64), dimension(:,:), intent(out) :: MB
B(1) = -Y(3)
B(2) = alpha*cgs_boltz*omega*Y(2)*Y(1)/(cgs_mhydr*miu) + alpha*omega*Y(4 &
   &   ) + (4.0d0/3.0d0)*alpha*cgs_stef*omega*Y(2)**4/cgs_c - 2*omega* &
   &   zeta*Y(4)
MB(1,1) = 0
MB(2,1) = -alpha*cgs_boltz*omega*Y(2)/(cgs_mhydr*miu)
MB(1,2) = 0
MB(2,2) = -alpha*cgs_boltz*omega*Y(1)/(cgs_mhydr*miu) - 16.0d0/3.0d0* &
   &   alpha*cgs_stef*omega*Y(2)**3/cgs_c
MB(1,3) = 1
MB(2,3) = 0
MB(1,4) = 0
MB(2,4) = omega*(-alpha + 2*zeta)
end subroutine

pure subroutine mrx_coeffmagndyfu_br (z,Y,F,B,MB)
use iso_fortran_env, only: real64
implicit none
real(real64), intent(in) :: z
real(real64), dimension(:), intent(in) :: Y
real(real64), dimension(:,:), intent(in) :: F
real(real64), dimension(:), intent(out) :: B
real(real64), dimension(:,:), intent(out) :: MB
B(1) = facc - 2*omega*z*zeta*Y(4) - Y(3)
B(2) = 2*cgs_stef*Y(2)**4 - Y(3)
MB(1,1) = 0
MB(2,1) = 0
MB(1,2) = 0
MB(2,2) = -8*cgs_stef*Y(2)**3
MB(1,3) = 1
MB(2,3) = 1
MB(1,4) = 2*omega*z*zeta
MB(2,4) = 0
end subroutine



!------------------------------------------------------------------------------!
! heating-cooling balance
! magnetic heating
! radiative energy transport
!------------------------------------------------------------------------------!

pure subroutine mrx_coeffmagncmpt (z,Y,D,F,A,MY,MD)
use iso_fortran_env, only: real64
implicit none
real(real64), intent(in) :: z
! first column: values, second column: 1ord derivatives
real(real64), dimension(:), intent(in) :: Y,D
! each row is one function: its value and derivatives to rho and T
real(real64), dimension(:,:), intent(in) :: F
! right-hand-side of the equation
real(real64), dimension(:), intent(out) :: A
! jacobians with respect to Y and dY/dz
real(real64), dimension(:,:), intent(out) :: MY, MD
A(1) = (-cgs_boltz*cgs_c*(D(2)*Y(1) + Y(2)*D(1)) - cgs_c*cgs_mhydr*miu*( &
   &   omega**2*z*Y(1) + D(5)) + cgs_mhydr*miu*Y(3)*(F(1,1) + F(1,3))*Y( &
   &   1))/(cgs_c*cgs_mhydr*miu)
A(2) = -1.0/(F(1,1) + F(1,3))*1.0/Y(1)*((16.0d0/3.0d0)*cgs_stef*Y(4)**3* &
   &   D(4) + Y(3)*(F(1,1) + F(1,3))*Y(1))
A(3) = -alpha*cgs_boltz*omega*Y(2)*Y(1)/(cgs_mhydr*miu) - alpha*omega*Y( &
   &   5) - 4.0d0/3.0d0*alpha*cgs_stef*omega*Y(4)**4/cgs_c + 2*omega* &
   &   zeta*Y(5) - D(3)
A(4) = alpha*cgs_boltz*omega*Y(2)*Y(1)/(cgs_mhydr*miu) + alpha*omega*Y(5 &
   &   ) + (4.0d0/3.0d0)*alpha*cgs_stef*omega*Y(4)**4/cgs_c - omega*z* &
   &   zeta*D(5) - 2*omega*zeta*Y(5)
A(5) = Y(2)*(cgs_c**2*cgs_mel*D(3) - 4*cgs_stef*(Y(2) - Y(4))*(4* &
   &   cgs_boltz*F(1,1)*Y(4)**4 + cgs_c**2*cgs_mel*F(1,3)*(Y(2)**2 + Y(4 &
   &   )**2)*(Y(2) + Y(4)))*Y(1))/(cgs_c**2*cgs_mel)
MY(1,1) = (cgs_boltz*cgs_c*D(2) + cgs_c*cgs_mhydr*miu*omega**2*z - &
   &   cgs_mhydr*miu*Y(3)*((F(2,1) + F(2,3))*Y(1) + F(1,1) + F(1,3)))/( &
   &   cgs_c*cgs_mhydr*miu)
MY(2,1) = -16.0d0/3.0d0*cgs_stef*Y(4)**3*D(4)*(F(1,1) + F(1,3))**(-2)*Y( &
   &   1)**(-2)*((F(2,1) + F(2,3))*Y(1) + F(1,1) + F(1,3))
MY(3,1) = alpha*cgs_boltz*omega*Y(2)/(cgs_mhydr*miu)
MY(4,1) = -alpha*cgs_boltz*omega*Y(2)/(cgs_mhydr*miu)
MY(5,1) = 4*cgs_stef*(Y(2) - Y(4))*Y(2)*(4*cgs_boltz*F(1,1)*Y(4)**4 + &
   &   cgs_c**2*cgs_mel*F(1,3)*(Y(2)**2 + Y(4)**2)*(Y(2) + Y(4)) + (4* &
   &   cgs_boltz*F(2,1)*Y(4)**4 + cgs_c**2*cgs_mel*F(2,3)*(Y(2)**2 + Y(4 &
   &   )**2)*(Y(2) + Y(4)))*Y(1))/(cgs_c**2*cgs_mel)
MY(1,2) = (cgs_boltz*cgs_c*D(1) - cgs_mhydr*miu*Y(3)*(F(3,1) + F(3,3))*Y &
   &   (1))/(cgs_c*cgs_mhydr*miu)
MY(2,2) = -16.0d0/3.0d0*cgs_stef*Y(4)**3*D(4)*(F(1,1) + F(1,3))**(-2)* &
   &   1.0/Y(1)*(F(3,1) + F(3,3))
MY(3,2) = alpha*cgs_boltz*omega*Y(1)/(cgs_mhydr*miu)
MY(4,2) = -alpha*cgs_boltz*omega*Y(1)/(cgs_mhydr*miu)
MY(5,2) = 32*cgs_boltz*cgs_stef*F(1,1)*Y(4)**4*Y(2)*Y(1)/(cgs_c**2* &
   &   cgs_mel) - 16*cgs_boltz*cgs_stef*F(1,1)*Y(4)**5*Y(1)/(cgs_c**2* &
   &   cgs_mel) + 16*cgs_boltz*cgs_stef*F(3,1)*Y(4)**4*Y(2)**2*Y(1)/( &
   &   cgs_c**2*cgs_mel) - 16*cgs_boltz*cgs_stef*F(3,1)*Y(4)**5*Y(2)*Y(1 &
   &   )/(cgs_c**2*cgs_mel) + 20*cgs_stef*F(1,3)*Y(2)**4*Y(1) - 4* &
   &   cgs_stef*F(1,3)*Y(4)**4*Y(1) + 4*cgs_stef*F(3,3)*Y(2)**5*Y(1) - 4 &
   &   *cgs_stef*F(3,3)*Y(4)**4*Y(2)*Y(1) - D(3)
MY(1,3) = -(F(1,1) + F(1,3))*Y(1)/cgs_c
MY(2,3) = 1
MY(3,3) = 0
MY(4,3) = 0
MY(5,3) = 0
MY(1,4) = 0
MY(2,4) = 16*cgs_stef*Y(4)**2*D(4)*1.0/(F(1,1) + F(1,3))*1.0/Y(1)
MY(3,4) = (16.0d0/3.0d0)*alpha*cgs_stef*omega*Y(4)**3/cgs_c
MY(4,4) = -16.0d0/3.0d0*alpha*cgs_stef*omega*Y(4)**3/cgs_c
MY(5,4) = -16*cgs_stef*Y(4)**3*Y(2)*(-4*cgs_boltz*F(1,1)*Y(2) + 5* &
   &   cgs_boltz*F(1,1)*Y(4) + cgs_c**2*cgs_mel*F(1,3))*Y(1)/(cgs_c**2* &
   &   cgs_mel)
MY(1,5) = 0
MY(2,5) = 0
MY(3,5) = omega*(alpha - 2*zeta)
MY(4,5) = omega*(-alpha + 2*zeta)
MY(5,5) = 0
MD(1,1) = cgs_boltz*Y(2)/(cgs_mhydr*miu)
MD(2,1) = 0
MD(3,1) = 0
MD(4,1) = 0
MD(5,1) = 0
MD(1,2) = cgs_boltz*Y(1)/(cgs_mhydr*miu)
MD(2,2) = 0
MD(3,2) = 0
MD(4,2) = 0
MD(5,2) = 0
MD(1,3) = 0
MD(2,3) = 0
MD(3,3) = 1
MD(4,3) = 0
MD(5,3) = -Y(2)
MD(1,4) = 0
MD(2,4) = (16.0d0/3.0d0)*cgs_stef*Y(4)**3*1.0/(F(1,1) + F(1,3))*1.0/Y(1)
MD(3,4) = 0
MD(4,4) = 0
MD(5,4) = 0
MD(1,5) = 1
MD(2,5) = 0
MD(3,5) = 0
MD(4,5) = omega*z*zeta
MD(5,5) = 0
end subroutine

pure subroutine mrx_coeffmagncmpt_bl (z,Y,F,B,MB)
use iso_fortran_env, only: real64
implicit none
real(real64), intent(in) :: z
real(real64), dimension(:), intent(in) :: Y
real(real64), dimension(:,:), intent(in) :: F
real(real64), dimension(:), intent(out) :: B
real(real64), dimension(:,:), intent(out) :: MB
B(1) = -Y(3)
B(2) = alpha*cgs_boltz*omega*Y(2)*Y(1)/(cgs_mhydr*miu) + alpha*omega*Y(5 &
   &   ) + (4.0d0/3.0d0)*alpha*cgs_stef*omega*Y(4)**4/cgs_c - 2*omega* &
   &   zeta*Y(5)
B(3) = -Y(2) + Y(4)
MB(1,1) = 0
MB(2,1) = -alpha*cgs_boltz*omega*Y(2)/(cgs_mhydr*miu)
MB(3,1) = 0
MB(1,2) = 0
MB(2,2) = -alpha*cgs_boltz*omega*Y(1)/(cgs_mhydr*miu)
MB(3,2) = 1
MB(1,3) = 1
MB(2,3) = 0
MB(3,3) = 0
MB(1,4) = 0
MB(2,4) = -16.0d0/3.0d0*alpha*cgs_stef*omega*Y(4)**3/cgs_c
MB(3,4) = -1
MB(1,5) = 0
MB(2,5) = omega*(-alpha + 2*zeta)
MB(3,5) = 0
end subroutine

pure subroutine mrx_coeffmagncmpt_br (z,Y,F,B,MB)
use iso_fortran_env, only: real64
implicit none
real(real64), intent(in) :: z
real(real64), dimension(:), intent(in) :: Y
real(real64), dimension(:,:), intent(in) :: F
real(real64), dimension(:), intent(out) :: B
real(real64), dimension(:,:), intent(out) :: MB
B(1) = facc - 2*omega*z*zeta*Y(5) - Y(3)
B(2) = 2*cgs_stef*Y(4)**4 - Y(3)
MB(1,1) = 0
MB(2,1) = 0
MB(1,2) = 0
MB(2,2) = 0
MB(1,3) = 1
MB(2,3) = 1
MB(1,4) = 0
MB(2,4) = -8*cgs_stef*Y(4)**3
MB(1,5) = 2*omega*z*zeta
MB(2,5) = 0
end subroutine



!------------------------------------------------------------------------------!
! thermal diffusion
! alpha prescription
! radiation + thermal conduction
!------------------------------------------------------------------------------!

pure subroutine mrx_coeffalphdyfucond (z,Y,D,F,A,MY,MD)
use iso_fortran_env, only: real64
implicit none
real(real64), intent(in) :: z
! first column: values, second column: 1ord derivatives
real(real64), dimension(:), intent(in) :: Y,D
! each row is one function: its value and derivatives to rho and T
real(real64), dimension(:,:), intent(in) :: F
! right-hand-side of the equation
real(real64), dimension(:), intent(out) :: A
! jacobians with respect to Y and dY/dz
real(real64), dimension(:,:), intent(out) :: MY, MD
A(1) = (-cgs_boltz*cgs_c*(D(2)*Y(1) + Y(2)*D(1)) - cgs_c*cgs_mhydr*miu* &
   &   omega**2*z*Y(1) + cgs_mhydr*miu*Y(3)*(F(1,1) + F(1,2))*Y(1))/( &
   &   cgs_c*cgs_mhydr*miu)
A(2) = -1.0/(F(1,1) + F(1,2))*1.0/Y(1)*((16.0d0/3.0d0)*cgs_stef*Y(2)**3* &
   &   D(2) + Y(3)*(F(1,1) + F(1,2))*Y(1))
A(3) = alpha*cgs_boltz*omega*Y(2)*Y(1)/(cgs_mhydr*miu) + (4.0d0/3.0d0)* &
   &   alpha*cgs_stef*omega*Y(2)**4/cgs_c - D(3) - D(4)
A(4) = -F(1,3)*D(2) - Y(4)
MY(1,1) = (cgs_boltz*cgs_c*D(2) + cgs_c*cgs_mhydr*miu*omega**2*z - &
   &   cgs_mhydr*miu*Y(3)*((F(2,1) + F(2,2))*Y(1) + F(1,1) + F(1,2)))/( &
   &   cgs_c*cgs_mhydr*miu)
MY(2,1) = -16.0d0/3.0d0*cgs_stef*Y(2)**3*D(2)*(F(1,1) + F(1,2))**(-2)*Y( &
   &   1)**(-2)*((F(2,1) + F(2,2))*Y(1) + F(1,1) + F(1,2))
MY(3,1) = -alpha*cgs_boltz*omega*Y(2)/(cgs_mhydr*miu)
MY(4,1) = F(2,3)*D(2)
MY(1,2) = (cgs_boltz*cgs_c*D(1) - cgs_mhydr*miu*Y(3)*(F(3,1) + F(3,2))*Y &
   &   (1))/(cgs_c*cgs_mhydr*miu)
MY(2,2) = (16.0d0/3.0d0)*cgs_stef*Y(2)**2*D(2)*(F(1,1) + F(1,2))**(-2)* &
   &   1.0/Y(1)*(3*F(1,1) + 3*F(1,2) - Y(2)*(F(3,1) + F(3,2)))
MY(3,2) = -alpha*cgs_boltz*omega*Y(1)/(cgs_mhydr*miu) - 16.0d0/3.0d0* &
   &   alpha*cgs_stef*omega*Y(2)**3/cgs_c
MY(4,2) = F(3,3)*D(2)
MY(1,3) = -(F(1,1) + F(1,2))*Y(1)/cgs_c
MY(2,3) = 1
MY(3,3) = 0
MY(4,3) = 0
MY(1,4) = 0
MY(2,4) = 0
MY(3,4) = 0
MY(4,4) = 1
MD(1,1) = cgs_boltz*Y(2)/(cgs_mhydr*miu)
MD(2,1) = 0
MD(3,1) = 0
MD(4,1) = 0
MD(1,2) = cgs_boltz*Y(1)/(cgs_mhydr*miu)
MD(2,2) = (16.0d0/3.0d0)*cgs_stef*Y(2)**3*1.0/(F(1,1) + F(1,2))*1.0/Y(1)
MD(3,2) = 0
MD(4,2) = F(1,3)
MD(1,3) = 0
MD(2,3) = 0
MD(3,3) = 1
MD(4,3) = 0
MD(1,4) = 0
MD(2,4) = 0
MD(3,4) = 1
MD(4,4) = 0
end subroutine

pure subroutine mrx_coeffalphdyfucond_bl (z,Y,F,B,MB)
use iso_fortran_env, only: real64
implicit none
real(real64), intent(in) :: z
real(real64), dimension(:), intent(in) :: Y
real(real64), dimension(:,:), intent(in) :: F
real(real64), dimension(:), intent(out) :: B
real(real64), dimension(:,:), intent(out) :: MB
B(1) = -Y(3)
B(2) = -Y(4)
MB(1,1) = 0
MB(2,1) = 0
MB(1,2) = 0
MB(2,2) = 0
MB(1,3) = 1
MB(2,3) = 0
MB(1,4) = 0
MB(2,4) = 1
end subroutine

pure subroutine mrx_coeffalphdyfucond_br (z,Y,F,B,MB)
use iso_fortran_env, only: real64
implicit none
real(real64), intent(in) :: z
real(real64), dimension(:), intent(in) :: Y
real(real64), dimension(:,:), intent(in) :: F
real(real64), dimension(:), intent(out) :: B
real(real64), dimension(:,:), intent(out) :: MB
B(1) = facc - Y(3) - Y(4)
B(2) = 2*cgs_stef*Y(2)**4 - Y(3)
MB(1,1) = 0
MB(2,1) = 0
MB(1,2) = 0
MB(2,2) = -8*cgs_stef*Y(2)**3
MB(1,3) = 1
MB(2,3) = 1
MB(1,4) = 1
MB(2,4) = 0
end subroutine



!------------------------------------------------------------------------------!
! heating-cooling balance
! alpha prescription
! radiation + thermal conduction
!------------------------------------------------------------------------------!

pure subroutine mrx_coeffalphcmptcond (z,Y,D,F,A,MY,MD)
use iso_fortran_env, only: real64
implicit none
real(real64), intent(in) :: z
! first column: values, second column: 1ord derivatives
real(real64), dimension(:), intent(in) :: Y,D
! each row is one function: its value and derivatives to rho and T
real(real64), dimension(:,:), intent(in) :: F
! right-hand-side of the equation
real(real64), dimension(:), intent(out) :: A
! jacobians with respect to Y and dY/dz
real(real64), dimension(:,:), intent(out) :: MY, MD
A(1) = (-cgs_boltz*cgs_c*(D(2)*Y(1) + Y(2)*D(1)) - cgs_c*cgs_mhydr*miu* &
   &   omega**2*z*Y(1) + cgs_mhydr*miu*Y(3)*(F(1,1) + F(1,3))*Y(1))/( &
   &   cgs_c*cgs_mhydr*miu)
A(2) = -1.0/(F(1,1) + F(1,3))*1.0/Y(1)*((16.0d0/3.0d0)*cgs_stef*Y(4)**3* &
   &   D(4) + Y(3)*(F(1,1) + F(1,3))*Y(1))
A(3) = alpha*cgs_boltz*omega*Y(2)*Y(1)/(cgs_mhydr*miu) + (4.0d0/3.0d0)* &
   &   alpha*cgs_stef*omega*Y(4)**4/cgs_c - D(3) - D(5)
A(4) = Y(2)*(cgs_c**2*cgs_mel*D(3) - 4*cgs_stef*(Y(2) - Y(4))*(4* &
   &   cgs_boltz*F(1,1)*Y(4)**4 + cgs_c**2*cgs_mel*F(1,3)*(Y(2)**2 + Y(4 &
   &   )**2)*(Y(2) + Y(4)))*Y(1))/(cgs_c**2*cgs_mel)
A(5) = -F(1,2)*D(2) - Y(5)
MY(1,1) = (cgs_boltz*cgs_c*D(2) + cgs_c*cgs_mhydr*miu*omega**2*z - &
   &   cgs_mhydr*miu*Y(3)*((F(2,1) + F(2,3))*Y(1) + F(1,1) + F(1,3)))/( &
   &   cgs_c*cgs_mhydr*miu)
MY(2,1) = -16.0d0/3.0d0*cgs_stef*Y(4)**3*D(4)*(F(1,1) + F(1,3))**(-2)*Y( &
   &   1)**(-2)*((F(2,1) + F(2,3))*Y(1) + F(1,1) + F(1,3))
MY(3,1) = -alpha*cgs_boltz*omega*Y(2)/(cgs_mhydr*miu)
MY(4,1) = 4*cgs_stef*(Y(2) - Y(4))*Y(2)*(4*cgs_boltz*F(1,1)*Y(4)**4 + &
   &   cgs_c**2*cgs_mel*F(1,3)*(Y(2)**2 + Y(4)**2)*(Y(2) + Y(4)) + (4* &
   &   cgs_boltz*F(2,1)*Y(4)**4 + cgs_c**2*cgs_mel*F(2,3)*(Y(2)**2 + Y(4 &
   &   )**2)*(Y(2) + Y(4)))*Y(1))/(cgs_c**2*cgs_mel)
MY(5,1) = F(2,2)*D(2)
MY(1,2) = (cgs_boltz*cgs_c*D(1) - cgs_mhydr*miu*Y(3)*(F(3,1) + F(3,3))*Y &
   &   (1))/(cgs_c*cgs_mhydr*miu)
MY(2,2) = -16.0d0/3.0d0*cgs_stef*Y(4)**3*D(4)*(F(1,1) + F(1,3))**(-2)* &
   &   1.0/Y(1)*(F(3,1) + F(3,3))
MY(3,2) = -alpha*cgs_boltz*omega*Y(1)/(cgs_mhydr*miu)
MY(4,2) = 32*cgs_boltz*cgs_stef*F(1,1)*Y(4)**4*Y(2)*Y(1)/(cgs_c**2* &
   &   cgs_mel) - 16*cgs_boltz*cgs_stef*F(1,1)*Y(4)**5*Y(1)/(cgs_c**2* &
   &   cgs_mel) + 16*cgs_boltz*cgs_stef*F(3,1)*Y(4)**4*Y(2)**2*Y(1)/( &
   &   cgs_c**2*cgs_mel) - 16*cgs_boltz*cgs_stef*F(3,1)*Y(4)**5*Y(2)*Y(1 &
   &   )/(cgs_c**2*cgs_mel) + 20*cgs_stef*F(1,3)*Y(2)**4*Y(1) - 4* &
   &   cgs_stef*F(1,3)*Y(4)**4*Y(1) + 4*cgs_stef*F(3,3)*Y(2)**5*Y(1) - 4 &
   &   *cgs_stef*F(3,3)*Y(4)**4*Y(2)*Y(1) - D(3)
MY(5,2) = F(3,2)*D(2)
MY(1,3) = -(F(1,1) + F(1,3))*Y(1)/cgs_c
MY(2,3) = 1
MY(3,3) = 0
MY(4,3) = 0
MY(5,3) = 0
MY(1,4) = 0
MY(2,4) = 16*cgs_stef*Y(4)**2*D(4)*1.0/(F(1,1) + F(1,3))*1.0/Y(1)
MY(3,4) = -16.0d0/3.0d0*alpha*cgs_stef*omega*Y(4)**3/cgs_c
MY(4,4) = -16*cgs_stef*Y(4)**3*Y(2)*(-4*cgs_boltz*F(1,1)*Y(2) + 5* &
   &   cgs_boltz*F(1,1)*Y(4) + cgs_c**2*cgs_mel*F(1,3))*Y(1)/(cgs_c**2* &
   &   cgs_mel)
MY(5,4) = 0
MY(1,5) = 0
MY(2,5) = 0
MY(3,5) = 0
MY(4,5) = 0
MY(5,5) = 1
MD(1,1) = cgs_boltz*Y(2)/(cgs_mhydr*miu)
MD(2,1) = 0
MD(3,1) = 0
MD(4,1) = 0
MD(5,1) = 0
MD(1,2) = cgs_boltz*Y(1)/(cgs_mhydr*miu)
MD(2,2) = 0
MD(3,2) = 0
MD(4,2) = 0
MD(5,2) = F(1,2)
MD(1,3) = 0
MD(2,3) = 0
MD(3,3) = 1
MD(4,3) = -Y(2)
MD(5,3) = 0
MD(1,4) = 0
MD(2,4) = (16.0d0/3.0d0)*cgs_stef*Y(4)**3*1.0/(F(1,1) + F(1,3))*1.0/Y(1)
MD(3,4) = 0
MD(4,4) = 0
MD(5,4) = 0
MD(1,5) = 0
MD(2,5) = 0
MD(3,5) = 1
MD(4,5) = 0
MD(5,5) = 0
end subroutine

pure subroutine mrx_coeffalphcmptcond_bl (z,Y,F,B,MB)
use iso_fortran_env, only: real64
implicit none
real(real64), intent(in) :: z
real(real64), dimension(:), intent(in) :: Y
real(real64), dimension(:,:), intent(in) :: F
real(real64), dimension(:), intent(out) :: B
real(real64), dimension(:,:), intent(out) :: MB
B(1) = -Y(3)
B(2) = -Y(2) + Y(4)
B(3) = -Y(5)
MB(1,1) = 0
MB(2,1) = 0
MB(3,1) = 0
MB(1,2) = 0
MB(2,2) = 1
MB(3,2) = 0
MB(1,3) = 1
MB(2,3) = 0
MB(3,3) = 0
MB(1,4) = 0
MB(2,4) = -1
MB(3,4) = 0
MB(1,5) = 0
MB(2,5) = 0
MB(3,5) = 1
end subroutine

pure subroutine mrx_coeffalphcmptcond_br (z,Y,F,B,MB)
use iso_fortran_env, only: real64
implicit none
real(real64), intent(in) :: z
real(real64), dimension(:), intent(in) :: Y
real(real64), dimension(:,:), intent(in) :: F
real(real64), dimension(:), intent(out) :: B
real(real64), dimension(:,:), intent(out) :: MB
B(1) = facc - Y(3) - Y(5)
B(2) = 2*cgs_stef*Y(4)**4 - Y(3)
MB(1,1) = 0
MB(2,1) = 0
MB(1,2) = 0
MB(2,2) = 0
MB(1,3) = 1
MB(2,3) = 1
MB(1,4) = 0
MB(2,4) = -8*cgs_stef*Y(4)**3
MB(1,5) = 1
MB(2,5) = 0
end subroutine



!------------------------------------------------------------------------------!
! thermal diffusion
! magnetic heating
! radiation + thermal conduction
!------------------------------------------------------------------------------!

pure subroutine mrx_coeffmagndyfucond (z,Y,D,F,A,MY,MD)
use iso_fortran_env, only: real64
implicit none
real(real64), intent(in) :: z
! first column: values, second column: 1ord derivatives
real(real64), dimension(:), intent(in) :: Y,D
! each row is one function: its value and derivatives to rho and T
real(real64), dimension(:,:), intent(in) :: F
! right-hand-side of the equation
real(real64), dimension(:), intent(out) :: A
! jacobians with respect to Y and dY/dz
real(real64), dimension(:,:), intent(out) :: MY, MD
A(1) = (-cgs_boltz*cgs_c*(D(2)*Y(1) + Y(2)*D(1)) - cgs_c*cgs_mhydr*miu*( &
   &   omega**2*z*Y(1) + D(4)) + cgs_mhydr*miu*Y(3)*(F(1,1) + F(1,2))*Y( &
   &   1))/(cgs_c*cgs_mhydr*miu)
A(2) = -1.0/(F(1,1) + F(1,2))*1.0/Y(1)*((16.0d0/3.0d0)*cgs_stef*Y(2)**3* &
   &   D(2) + Y(3)*(F(1,1) + F(1,2))*Y(1))
A(3) = -alpha*cgs_boltz*omega*Y(2)*Y(1)/(cgs_mhydr*miu) - alpha*omega*Y( &
   &   4) - 4.0d0/3.0d0*alpha*cgs_stef*omega*Y(2)**4/cgs_c + 2*omega* &
   &   zeta*Y(4) - D(3) - D(5)
A(4) = alpha*cgs_boltz*omega*Y(2)*Y(1)/(cgs_mhydr*miu) + alpha*omega*Y(4 &
   &   ) + (4.0d0/3.0d0)*alpha*cgs_stef*omega*Y(2)**4/cgs_c - omega*z* &
   &   zeta*D(4) - 2*omega*zeta*Y(4)
A(5) = -F(1,3)*D(2) - Y(5)
MY(1,1) = (cgs_boltz*cgs_c*D(2) + cgs_c*cgs_mhydr*miu*omega**2*z - &
   &   cgs_mhydr*miu*Y(3)*((F(2,1) + F(2,2))*Y(1) + F(1,1) + F(1,2)))/( &
   &   cgs_c*cgs_mhydr*miu)
MY(2,1) = -16.0d0/3.0d0*cgs_stef*Y(2)**3*D(2)*(F(1,1) + F(1,2))**(-2)*Y( &
   &   1)**(-2)*((F(2,1) + F(2,2))*Y(1) + F(1,1) + F(1,2))
MY(3,1) = alpha*cgs_boltz*omega*Y(2)/(cgs_mhydr*miu)
MY(4,1) = -alpha*cgs_boltz*omega*Y(2)/(cgs_mhydr*miu)
MY(5,1) = F(2,3)*D(2)
MY(1,2) = (cgs_boltz*cgs_c*D(1) - cgs_mhydr*miu*Y(3)*(F(3,1) + F(3,2))*Y &
   &   (1))/(cgs_c*cgs_mhydr*miu)
MY(2,2) = (16.0d0/3.0d0)*cgs_stef*Y(2)**2*D(2)*(F(1,1) + F(1,2))**(-2)* &
   &   1.0/Y(1)*(3*F(1,1) + 3*F(1,2) - Y(2)*(F(3,1) + F(3,2)))
MY(3,2) = alpha*cgs_boltz*omega*Y(1)/(cgs_mhydr*miu) + (16.0d0/3.0d0)* &
   &   alpha*cgs_stef*omega*Y(2)**3/cgs_c
MY(4,2) = -alpha*cgs_boltz*omega*Y(1)/(cgs_mhydr*miu) - 16.0d0/3.0d0* &
   &   alpha*cgs_stef*omega*Y(2)**3/cgs_c
MY(5,2) = F(3,3)*D(2)
MY(1,3) = -(F(1,1) + F(1,2))*Y(1)/cgs_c
MY(2,3) = 1
MY(3,3) = 0
MY(4,3) = 0
MY(5,3) = 0
MY(1,4) = 0
MY(2,4) = 0
MY(3,4) = omega*(alpha - 2*zeta)
MY(4,4) = omega*(-alpha + 2*zeta)
MY(5,4) = 0
MY(1,5) = 0
MY(2,5) = 0
MY(3,5) = 0
MY(4,5) = 0
MY(5,5) = 1
MD(1,1) = cgs_boltz*Y(2)/(cgs_mhydr*miu)
MD(2,1) = 0
MD(3,1) = 0
MD(4,1) = 0
MD(5,1) = 0
MD(1,2) = cgs_boltz*Y(1)/(cgs_mhydr*miu)
MD(2,2) = (16.0d0/3.0d0)*cgs_stef*Y(2)**3*1.0/(F(1,1) + F(1,2))*1.0/Y(1)
MD(3,2) = 0
MD(4,2) = 0
MD(5,2) = F(1,3)
MD(1,3) = 0
MD(2,3) = 0
MD(3,3) = 1
MD(4,3) = 0
MD(5,3) = 0
MD(1,4) = 1
MD(2,4) = 0
MD(3,4) = 0
MD(4,4) = omega*z*zeta
MD(5,4) = 0
MD(1,5) = 0
MD(2,5) = 0
MD(3,5) = 1
MD(4,5) = 0
MD(5,5) = 0
end subroutine

pure subroutine mrx_coeffmagndyfucond_bl (z,Y,F,B,MB)
use iso_fortran_env, only: real64
implicit none
real(real64), intent(in) :: z
real(real64), dimension(:), intent(in) :: Y
real(real64), dimension(:,:), intent(in) :: F
real(real64), dimension(:), intent(out) :: B
real(real64), dimension(:,:), intent(out) :: MB
B(1) = -Y(3)
B(2) = alpha*cgs_boltz*omega*Y(2)*Y(1)/(cgs_mhydr*miu) + alpha*omega*Y(4 &
   &   ) + (4.0d0/3.0d0)*alpha*cgs_stef*omega*Y(2)**4/cgs_c - 2*omega* &
   &   zeta*Y(4)
B(3) = -Y(5)
MB(1,1) = 0
MB(2,1) = -alpha*cgs_boltz*omega*Y(2)/(cgs_mhydr*miu)
MB(3,1) = 0
MB(1,2) = 0
MB(2,2) = -alpha*cgs_boltz*omega*Y(1)/(cgs_mhydr*miu) - 16.0d0/3.0d0* &
   &   alpha*cgs_stef*omega*Y(2)**3/cgs_c
MB(3,2) = 0
MB(1,3) = 1
MB(2,3) = 0
MB(3,3) = 0
MB(1,4) = 0
MB(2,4) = omega*(-alpha + 2*zeta)
MB(3,4) = 0
MB(1,5) = 0
MB(2,5) = 0
MB(3,5) = 1
end subroutine

pure subroutine mrx_coeffmagndyfucond_br (z,Y,F,B,MB)
use iso_fortran_env, only: real64
implicit none
real(real64), intent(in) :: z
real(real64), dimension(:), intent(in) :: Y
real(real64), dimension(:,:), intent(in) :: F
real(real64), dimension(:), intent(out) :: B
real(real64), dimension(:,:), intent(out) :: MB
B(1) = facc - 2*omega*z*zeta*Y(4) - Y(3) - Y(5)
B(2) = 2*cgs_stef*Y(2)**4 - Y(3)
MB(1,1) = 0
MB(2,1) = 0
MB(1,2) = 0
MB(2,2) = -8*cgs_stef*Y(2)**3
MB(1,3) = 1
MB(2,3) = 1
MB(1,4) = 2*omega*z*zeta
MB(2,4) = 0
MB(1,5) = 1
MB(2,5) = 0
end subroutine



!------------------------------------------------------------------------------!
! heating-cooling balance
! magnetic heating
! radiation + thermal conduction
!------------------------------------------------------------------------------!

pure subroutine mrx_coeffmagncmptcond (z,Y,D,F,A,MY,MD)
use iso_fortran_env, only: real64
implicit none
real(real64), intent(in) :: z
! first column: values, second column: 1ord derivatives
real(real64), dimension(:), intent(in) :: Y,D
! each row is one function: its value and derivatives to rho and T
real(real64), dimension(:,:), intent(in) :: F
! right-hand-side of the equation
real(real64), dimension(:), intent(out) :: A
! jacobians with respect to Y and dY/dz
real(real64), dimension(:,:), intent(out) :: MY, MD
A(1) = (-cgs_boltz*cgs_c*(D(2)*Y(1) + Y(2)*D(1)) - cgs_c*cgs_mhydr*miu*( &
   &   omega**2*z*Y(1) + D(5)) + cgs_mhydr*miu*Y(3)*(F(1,1) + F(1,3))*Y( &
   &   1))/(cgs_c*cgs_mhydr*miu)
A(2) = -1.0/(F(1,1) + F(1,3))*1.0/Y(1)*((16.0d0/3.0d0)*cgs_stef*Y(4)**3* &
   &   D(4) + Y(3)*(F(1,1) + F(1,3))*Y(1))
A(3) = -alpha*cgs_boltz*omega*Y(2)*Y(1)/(cgs_mhydr*miu) - alpha*omega*Y( &
   &   5) - 4.0d0/3.0d0*alpha*cgs_stef*omega*Y(4)**4/cgs_c + 2*omega* &
   &   zeta*Y(5) - D(3) - D(6)
A(4) = alpha*cgs_boltz*omega*Y(2)*Y(1)/(cgs_mhydr*miu) + alpha*omega*Y(5 &
   &   ) + (4.0d0/3.0d0)*alpha*cgs_stef*omega*Y(4)**4/cgs_c - omega*z* &
   &   zeta*D(5) - 2*omega*zeta*Y(5)
A(5) = Y(2)*(cgs_c**2*cgs_mel*D(3) - 4*cgs_stef*(Y(2) - Y(4))*(4* &
   &   cgs_boltz*F(1,1)*Y(4)**4 + cgs_c**2*cgs_mel*F(1,3)*(Y(2)**2 + Y(4 &
   &   )**2)*(Y(2) + Y(4)))*Y(1))/(cgs_c**2*cgs_mel)
A(6) = -F(1,2)*D(2) - Y(6)
MY(1,1) = (cgs_boltz*cgs_c*D(2) + cgs_c*cgs_mhydr*miu*omega**2*z - &
   &   cgs_mhydr*miu*Y(3)*((F(2,1) + F(2,3))*Y(1) + F(1,1) + F(1,3)))/( &
   &   cgs_c*cgs_mhydr*miu)
MY(2,1) = -16.0d0/3.0d0*cgs_stef*Y(4)**3*D(4)*(F(1,1) + F(1,3))**(-2)*Y( &
   &   1)**(-2)*((F(2,1) + F(2,3))*Y(1) + F(1,1) + F(1,3))
MY(3,1) = alpha*cgs_boltz*omega*Y(2)/(cgs_mhydr*miu)
MY(4,1) = -alpha*cgs_boltz*omega*Y(2)/(cgs_mhydr*miu)
MY(5,1) = 4*cgs_stef*(Y(2) - Y(4))*Y(2)*(4*cgs_boltz*F(1,1)*Y(4)**4 + &
   &   cgs_c**2*cgs_mel*F(1,3)*(Y(2)**2 + Y(4)**2)*(Y(2) + Y(4)) + (4* &
   &   cgs_boltz*F(2,1)*Y(4)**4 + cgs_c**2*cgs_mel*F(2,3)*(Y(2)**2 + Y(4 &
   &   )**2)*(Y(2) + Y(4)))*Y(1))/(cgs_c**2*cgs_mel)
MY(6,1) = F(2,2)*D(2)
MY(1,2) = (cgs_boltz*cgs_c*D(1) - cgs_mhydr*miu*Y(3)*(F(3,1) + F(3,3))*Y &
   &   (1))/(cgs_c*cgs_mhydr*miu)
MY(2,2) = -16.0d0/3.0d0*cgs_stef*Y(4)**3*D(4)*(F(1,1) + F(1,3))**(-2)* &
   &   1.0/Y(1)*(F(3,1) + F(3,3))
MY(3,2) = alpha*cgs_boltz*omega*Y(1)/(cgs_mhydr*miu)
MY(4,2) = -alpha*cgs_boltz*omega*Y(1)/(cgs_mhydr*miu)
MY(5,2) = 32*cgs_boltz*cgs_stef*F(1,1)*Y(4)**4*Y(2)*Y(1)/(cgs_c**2* &
   &   cgs_mel) - 16*cgs_boltz*cgs_stef*F(1,1)*Y(4)**5*Y(1)/(cgs_c**2* &
   &   cgs_mel) + 16*cgs_boltz*cgs_stef*F(3,1)*Y(4)**4*Y(2)**2*Y(1)/( &
   &   cgs_c**2*cgs_mel) - 16*cgs_boltz*cgs_stef*F(3,1)*Y(4)**5*Y(2)*Y(1 &
   &   )/(cgs_c**2*cgs_mel) + 20*cgs_stef*F(1,3)*Y(2)**4*Y(1) - 4* &
   &   cgs_stef*F(1,3)*Y(4)**4*Y(1) + 4*cgs_stef*F(3,3)*Y(2)**5*Y(1) - 4 &
   &   *cgs_stef*F(3,3)*Y(4)**4*Y(2)*Y(1) - D(3)
MY(6,2) = F(3,2)*D(2)
MY(1,3) = -(F(1,1) + F(1,3))*Y(1)/cgs_c
MY(2,3) = 1
MY(3,3) = 0
MY(4,3) = 0
MY(5,3) = 0
MY(6,3) = 0
MY(1,4) = 0
MY(2,4) = 16*cgs_stef*Y(4)**2*D(4)*1.0/(F(1,1) + F(1,3))*1.0/Y(1)
MY(3,4) = (16.0d0/3.0d0)*alpha*cgs_stef*omega*Y(4)**3/cgs_c
MY(4,4) = -16.0d0/3.0d0*alpha*cgs_stef*omega*Y(4)**3/cgs_c
MY(5,4) = -16*cgs_stef*Y(4)**3*Y(2)*(-4*cgs_boltz*F(1,1)*Y(2) + 5* &
   &   cgs_boltz*F(1,1)*Y(4) + cgs_c**2*cgs_mel*F(1,3))*Y(1)/(cgs_c**2* &
   &   cgs_mel)
MY(6,4) = 0
MY(1,5) = 0
MY(2,5) = 0
MY(3,5) = omega*(alpha - 2*zeta)
MY(4,5) = omega*(-alpha + 2*zeta)
MY(5,5) = 0
MY(6,5) = 0
MY(1,6) = 0
MY(2,6) = 0
MY(3,6) = 0
MY(4,6) = 0
MY(5,6) = 0
MY(6,6) = 1
MD(1,1) = cgs_boltz*Y(2)/(cgs_mhydr*miu)
MD(2,1) = 0
MD(3,1) = 0
MD(4,1) = 0
MD(5,1) = 0
MD(6,1) = 0
MD(1,2) = cgs_boltz*Y(1)/(cgs_mhydr*miu)
MD(2,2) = 0
MD(3,2) = 0
MD(4,2) = 0
MD(5,2) = 0
MD(6,2) = F(1,2)
MD(1,3) = 0
MD(2,3) = 0
MD(3,3) = 1
MD(4,3) = 0
MD(5,3) = -Y(2)
MD(6,3) = 0
MD(1,4) = 0
MD(2,4) = (16.0d0/3.0d0)*cgs_stef*Y(4)**3*1.0/(F(1,1) + F(1,3))*1.0/Y(1)
MD(3,4) = 0
MD(4,4) = 0
MD(5,4) = 0
MD(6,4) = 0
MD(1,5) = 1
MD(2,5) = 0
MD(3,5) = 0
MD(4,5) = omega*z*zeta
MD(5,5) = 0
MD(6,5) = 0
MD(1,6) = 0
MD(2,6) = 0
MD(3,6) = 1
MD(4,6) = 0
MD(5,6) = 0
MD(6,6) = 0
end subroutine

pure subroutine mrx_coeffmagncmptcond_bl (z,Y,F,B,MB)
use iso_fortran_env, only: real64
implicit none
real(real64), intent(in) :: z
real(real64), dimension(:), intent(in) :: Y
real(real64), dimension(:,:), intent(in) :: F
real(real64), dimension(:), intent(out) :: B
real(real64), dimension(:,:), intent(out) :: MB
B(1) = -Y(3)
B(2) = alpha*cgs_boltz*omega*Y(2)*Y(1)/(cgs_mhydr*miu) + alpha*omega*Y(5 &
   &   ) + (4.0d0/3.0d0)*alpha*cgs_stef*omega*Y(4)**4/cgs_c - 2*omega* &
   &   zeta*Y(5)
B(3) = -Y(2) + Y(4)
B(4) = -Y(6)
MB(1,1) = 0
MB(2,1) = -alpha*cgs_boltz*omega*Y(2)/(cgs_mhydr*miu)
MB(3,1) = 0
MB(4,1) = 0
MB(1,2) = 0
MB(2,2) = -alpha*cgs_boltz*omega*Y(1)/(cgs_mhydr*miu)
MB(3,2) = 1
MB(4,2) = 0
MB(1,3) = 1
MB(2,3) = 0
MB(3,3) = 0
MB(4,3) = 0
MB(1,4) = 0
MB(2,4) = -16.0d0/3.0d0*alpha*cgs_stef*omega*Y(4)**3/cgs_c
MB(3,4) = -1
MB(4,4) = 0
MB(1,5) = 0
MB(2,5) = omega*(-alpha + 2*zeta)
MB(3,5) = 0
MB(4,5) = 0
MB(1,6) = 0
MB(2,6) = 0
MB(3,6) = 0
MB(4,6) = 1
end subroutine

pure subroutine mrx_coeffmagncmptcond_br (z,Y,F,B,MB)
use iso_fortran_env, only: real64
implicit none
real(real64), intent(in) :: z
real(real64), dimension(:), intent(in) :: Y
real(real64), dimension(:,:), intent(in) :: F
real(real64), dimension(:), intent(out) :: B
real(real64), dimension(:,:), intent(out) :: MB
B(1) = facc - 2*omega*z*zeta*Y(5) - Y(3) - Y(6)
B(2) = 2*cgs_stef*Y(4)**4 - Y(3)
MB(1,1) = 0
MB(2,1) = 0
MB(1,2) = 0
MB(2,2) = 0
MB(1,3) = 1
MB(2,3) = 1
MB(1,4) = 0
MB(2,4) = -8*cgs_stef*Y(4)**3
MB(1,5) = 2*omega*z*zeta
MB(2,5) = 0
MB(1,6) = 1
MB(2,6) = 0
end subroutine


